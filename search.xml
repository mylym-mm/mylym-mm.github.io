<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MVC &amp;&amp; API</title>
    <url>/2021/05/14/20-36-11/</url>
    <content><![CDATA[<p>概览：<br>1.API接口TOKEN设计（API的特点、api_token、user_token）        2.MVC        3.前端控制器模式MVC</p>
<span id="more"></span>

<h2 id="API接口TOKEN设计"><a href="#API接口TOKEN设计" class="headerlink" title="API接口TOKEN设计"></a><a href="https://www.cnblogs.com/xingxia/p/api_token.html">API接口TOKEN设计</a></h2><p>首先需要知道API是什么？<br>API（Application Programming Interface）即应用程序接口。你可以认为 API 是一个软件组件或是一个 Web  服务与外界进行的交互的接口。而我们在这里要谈论的，是作为一家公司如何跟外界进行交互。从另一个角度来说，API  是一套协议，规定了我们与外界的沟通方式：如何发送请求和接收响应。</p>
<p><strong>API的特点</strong>：</p>
<p>　　1、因为是非开放性的，所以所有的接口都是封闭的，只对公司内部的产品有效；<br>        2、因为是非开放性的，所以OAuth那套协议是行不通的，因为没有中间用户的授权过程；<br>        3、接口分为需要用户登录才能访问的和不需要用户登录就可访问的；</p>
<p>​            针对以上特点，移动端与服务端的通信就需要两种不同的TOKEN，一种针对接口的api_token,一种针对用户的user_token;</p>
<p><strong>一.api_token</strong></p>
<p>　　它的职责是保持接口访问的隐蔽性和有效性，保证接口只有可信任的来源才可以访问，参考思路如下：</p>
<p>　　按服务器端和客户端都拥有的共同属性生成一个随机串，客户端生成这个串，服务器也按同样算法生成一个串，用来校验客户端的串。</p>
<p>　　现在的接口基本是mvc模式，URL基本是restful风格，URL大体格式如下：</p>
<p>　　<a href="http://www.api.com/%E6%A8%A1%E5%9D%97%E5%90%8D/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8D/%E6%96%B9%E6%B3%95%E5%90%8D?%E5%8F%82%E6%95%B0%E5%90%8D1=%E5%8F%82%E6%95%B0%E5%80%BC1&amp;%E5%8F%82%E6%95%B0%E5%90%8D2=%E5%8F%82%E6%95%B0%E5%80%BC2">http://www.api.com/模块名/控制器名/方法名?参数名1=参数值1&amp;参数名2=参数值2</a></p>
<p>　　接口token生成规则参考如下：</p>
<p>　　　　$api_token = md5 (‘模块名’ + ‘控制器名’ + ‘方法名’ + ‘2018-1-18’ + ‘加密密钥’) = 789fed3842aabd834e9a5dd7735532de2</p>
<p>　　　　1.’2018-1-18’ 为当天时间</p>
<p>　　　　2.’加密密钥’为私有的加密密钥，手机端需要在服务端注册一个“接口使用者”账号后，系统会分配一个账号及密码，数据表设计参考如下：</p>
<p>　　　　　　字段名及字段类型　　　　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client_id varchar(20) 客户端ID</span><br><span class="line">client_secret varchar(20) 客户端(加密)密钥 </span><br></pre></td></tr></table></figure>

<p>　　　　　　服务端接口校验，PHP实现流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;获取GET参数值</span><br><span class="line"> </span><br><span class="line">    $module &#x3D; $_GET[&#39;module&#39;];</span><br><span class="line"> </span><br><span class="line">    $controller &#x3D; $_GET[&#39;controller&#39;]</span><br><span class="line"> </span><br><span class="line">    $action &#x3D; $_GET[&#39;action&#39;];</span><br><span class="line"> </span><br><span class="line">    $client_id &#x3D; $_GET[&#39;client_id&#39;];</span><br><span class="line"> </span><br><span class="line">    $api_token &#x3D; $_GET[&#39;&#39;api_token];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;根据客户端传过来的client_id，查询数据库，获取对应的client_secret</span><br><span class="line"> </span><br><span class="line">    $client_secret &#x3D; getClientSecret($client_id);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;服务端重新生成一个api_token</span><br><span class="line"> </span><br><span class="line">    $api_token_server &#x3D; md5($module . $controller . $action . date(&#39;Y-m-d&#39;, time()) . $client_secret);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;客户端传过来的api_token与服务端生成的api_token进行校对，如果不相等，则表示验证失败</span><br><span class="line"> </span><br><span class="line">    if ($api_token !&#x3D; $api_token_server) &#123;</span><br><span class="line"> </span><br><span class="line">        exit(&#39;access deny&#39;); &#x2F;&#x2F;拒绝访问</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;验证通过，返回数据给客户端</span><br><span class="line"> </span><br><span class="line">?&gt;    </span><br></pre></td></tr></table></figure>



<p><strong>二.user_token</strong></p>
<p>　　它的职责是保护用户的用户名及密码多次提交，以防密码泄露。</p>
<p>　　如果接口需要用户登录，其访问流程如下：</p>
<p>　　　　1、用户提交“用户名”和“密码”，实现登录（条件允许，这一步最好走https）；</p>
<p>　　　　2、登录成功后，服务端返回一个user_token，生成规则参考如下：</p>
<p>　　　　　　user_token = md5(‘用户的uid’ + ‘Unix时间戳’) = etye0fgkgk4ca2ttdsl0ae9a5dd77471fgf</p>
<p>　　　　　　服务端用数据表维护user_token的状态，表设计如下：</p>
<p>　　　　　　字段名及字段类型如下：　　　　　　　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user_id int(11) 用户ID</span><br><span class="line">user_token varchar(36) 用户token</span><br><span class="line">expire_time int 过期时间（Unix时间戳）  </span><br></pre></td></tr></table></figure>

<p>　　服务端生成user_token后，返回给客户端（自己存储），客户端每次接口请求时，如果接口需要用户登录才能访问，则需要把 user_id与user_token传回给服务端，服务端接受到这2个参数后，需要做以下几步：</p>
<p>　　　　  1、检测user_token的有效性；</p>
<p>　　　　2、删除过期的user_token表记录；</p>
<p>　　　　3、根据user_id，user_token 获取表记录，如果表记录不存在，直接返回错误，如果记录存在，则进行下一步；</p>
<p>　　　　4、更新user_token 的过期时间（延期，保证其有效期内连续操作不掉线）；</p>
<p>　　　　5、返回接口数据；</p>
<p>接口用例如下：添加测试接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL： http:&#x2F;&#x2F;www.api.com&#x2F;demo&#x2F;index&#x2F;add-demo?client_id&#x3D;wt373uesksklwkskx36sr5858t6&amp;api_token&#x3D;880fed4ca2aabd20ae9eessa74711de2&amp;user_token&#x3D;etye0fgkgk4ca2asehxlejeje5dd77471fgf&amp;user_id&#x3D;12</span><br><span class="line">请求方式： POST</span><br><span class="line">POST参数：title&#x3D;哈喽&amp;content&#x3D;我的世界</span><br><span class="line">返回数据：</span><br><span class="line">&#123;&#39;code&#39;&#x3D;&gt; 1,&#x2F;&#x2F; 1:成功 0:失败</span><br><span class="line">&#39;msg&#39;&#x3D;&gt; &#39;成功&#x2F;失败，无权访问&#39;</span><br><span class="line">&#39;data&#39;&#x3D;&gt; []&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong>  视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> -控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
<li><img src="https://www.runoob.com/wp-content/uploads/2014/08/1200px-ModelViewControllerDiagram2.svg_.png" alt="三者关系"></li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>我们将创建一个作为模型的 <em>Student</em> 对象。<em>StudentView</em> 是一个把学生详细信息输出到控制台的视图类，<em>StudentController</em> 是负责存储数据到 <em>Student</em> 对象中的控制器类，并相应地更新视图 <em>StudentView</em>。</p>
<p><em>MVCPatternDemo</em>，我们的演示类使用 <em>StudentController</em> 来演示 MVC 模式的用法。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/mvc-2.svg" alt="类图"></p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h5><p>创建模型。</p>
<h6 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">	private String rollNo;   </span><br><span class="line">	private String name;   </span><br><span class="line">	public String getRollNo() &#123;</span><br><span class="line">    	return rollNo;   </span><br><span class="line">    &#125;   </span><br><span class="line">    public void setRollNo(String rollNo) &#123;      </span><br><span class="line">    	this.rollNo &#x3D; rollNo;   </span><br><span class="line">    &#125;   </span><br><span class="line">    public String getName() &#123;      </span><br><span class="line">    	return name;   </span><br><span class="line">    &#125;   </span><br><span class="line">    public void setName(String name) &#123;      </span><br><span class="line">    	this.name &#x3D; name;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h5><p>创建视图。</p>
<h6 id="StudentView-java"><a href="#StudentView-java" class="headerlink" title="StudentView.java"></a>StudentView.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentView</span> </span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStudentDetails</span><span class="params">(String studentName, String studentRollNo)</span></span>&#123;      			System.out.println(<span class="string">&quot;Student: &quot;</span>);      </span><br><span class="line">		System.out.println(<span class="string">&quot;Name: &quot;</span> + studentName);      </span><br><span class="line">		System.out.println(<span class="string">&quot;Roll No: &quot;</span> + studentRollNo);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h5><p>创建控制器。</p>
<h6 id="StudentController-java"><a href="#StudentController-java" class="headerlink" title="StudentController.java"></a>StudentController.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> Student model;   </span><br><span class="line">	<span class="keyword">private</span> StudentView view;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentController</span><span class="params">(Student model, StudentView view)</span></span>&#123;      </span><br><span class="line">		<span class="keyword">this</span>.model = model;      </span><br><span class="line">		<span class="keyword">this</span>.view = view;   </span><br><span class="line">	&#125;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentName</span><span class="params">(String name)</span></span>&#123;     </span><br><span class="line">        model.setName(name);      </span><br><span class="line">    &#125;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStudentName</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> model.getName();     </span><br><span class="line">    &#125;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentRollNo</span><span class="params">(String rollNo)</span></span>&#123;      </span><br><span class="line">        model.setRollNo(rollNo);       </span><br><span class="line">    &#125;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStudentRollNo</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> model.getRollNo();      </span><br><span class="line">    &#125;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateView</span><span class="params">()</span></span>&#123;             </span><br><span class="line">        view.printStudentDetails(model.getName(), model.getRollNo());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h5><p>使用 <em>StudentController</em> 方法来演示 MVC 设计模式的用法。</p>
<h6 id="MVCPatternDemo-java"><a href="#MVCPatternDemo-java" class="headerlink" title="MVCPatternDemo.java"></a>MVCPatternDemo.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MVCPatternDemo</span> </span>&#123;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">    <span class="comment">//从数据库获取学生记录      </span></span><br><span class="line">    Student model  = retrieveStudentFromDatabase();       </span><br><span class="line">    <span class="comment">//创建一个视图：把学生详细信息输出到控制台      </span></span><br><span class="line">    StudentView view = <span class="keyword">new</span> StudentView();       </span><br><span class="line">    StudentController controller = <span class="keyword">new</span> StudentController(model, view);       </span><br><span class="line">    controller.updateView();       </span><br><span class="line">    <span class="comment">//更新模型数据     </span></span><br><span class="line">    controller.setStudentName(<span class="string">&quot;John&quot;</span>);      </span><br><span class="line">    controller.updateView();   </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Student <span class="title">retrieveStudentFromDatabase</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        Student student = <span class="keyword">new</span> Student();      </span><br><span class="line">        student.setName(<span class="string">&quot;Robert&quot;</span>);      </span><br><span class="line">        student.setRollNo(<span class="string">&quot;10&quot;</span>);      </span><br><span class="line">        <span class="keyword">return</span> student;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h5><p>执行程序，输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student: </span><br><span class="line">Name: Robert</span><br><span class="line">Roll No: <span class="number">10</span></span><br><span class="line">Student: </span><br><span class="line">Name: John</span><br><span class="line">Roll No: <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h2 id="前端控制器模式MVC"><a href="#前端控制器模式MVC" class="headerlink" title="前端控制器模式MVC"></a>前端控制器模式MVC</h2><p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p>
<ul>
<li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li>
<li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li>
<li><strong>视图（View）</strong> - 视图是为请求而创建的对象。</li>
</ul>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>我们将创建 <em>FrontController</em>、<em>Dispatcher</em> 分别当作前端控制器和调度器。<em>HomeView</em> 和 <em>StudentView</em> 表示各种为前端控制器接收到的请求而创建的视图。</p>
<p><em>FrontControllerPatternDemo</em>，我们的演示类使用 <em>FrontController</em> 来演示前端控制器设计模式。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/frontcontroller_pattern_uml_diagram.jpg" alt="前端控制器模式的 UML 图"></p>
<h5 id="步骤-1-1"><a href="#步骤-1-1" class="headerlink" title="步骤 1"></a>步骤 1</h5><p>创建视图。</p>
<h6 id="HomeView-java"><a href="#HomeView-java" class="headerlink" title="HomeView.java"></a>HomeView.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeView</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying Home Page&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="StudentView-java-1"><a href="#StudentView-java-1" class="headerlink" title="StudentView.java"></a>StudentView.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentView</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying Student Page&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-2-1"><a href="#步骤-2-1" class="headerlink" title="步骤 2"></a>步骤 2</h5><p>创建调度器 Dispatcher。</p>
<h6 id="Dispatcher-java"><a href="#Dispatcher-java" class="headerlink" title="Dispatcher.java"></a>Dispatcher.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> StudentView studentView;   </span><br><span class="line">    <span class="keyword">private</span> HomeView homeView; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        studentView = <span class="keyword">new</span> StudentView();      </span><br><span class="line">        homeView = <span class="keyword">new</span> HomeView(); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(String request)</span></span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(request.equalsIgnoreCase(<span class="string">&quot;STUDENT&quot;</span>))&#123;  </span><br><span class="line">            studentView.show();     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;       </span><br><span class="line">            homeView.show();     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-3-1"><a href="#步骤-3-1" class="headerlink" title="步骤 3"></a>步骤 3</h5><p>创建前端控制器 FrontController。</p>
<h6 id="FrontController-java"><a href="#FrontController-java" class="headerlink" title="FrontController.java"></a>FrontController.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontController</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> Dispatcher dispatcher;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrontController</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        dispatcher = <span class="keyword">new</span> Dispatcher();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAuthenticUser</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;User is authenticated successfully.&quot;</span>);      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trackRequest</span><span class="params">(String request)</span></span>&#123;   </span><br><span class="line">        System.out.println(<span class="string">&quot;Page requested: &quot;</span> + request);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchRequest</span><span class="params">(String request)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//记录每一个请求    </span></span><br><span class="line">        trackRequest(request);  </span><br><span class="line">        <span class="comment">//对用户进行身份验证      </span></span><br><span class="line">        <span class="keyword">if</span>(isAuthenticUser())&#123;   </span><br><span class="line">            dispatcher.dispatch(request); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-4-1"><a href="#步骤-4-1" class="headerlink" title="步骤 4"></a>步骤 4</h5><p>使用 <em>FrontController</em> 来演示前端控制器设计模式。</p>
<h6 id="FrontControllerPatternDemo-java"><a href="#FrontControllerPatternDemo-java" class="headerlink" title="FrontControllerPatternDemo.java"></a>FrontControllerPatternDemo.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontControllerPatternDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">        FrontController frontController = <span class="keyword">new</span> FrontController();      		</span><br><span class="line">        frontController.dispatchRequest(<span class="string">&quot;HOME&quot;</span>);  </span><br><span class="line">        frontController.dispatchRequest(<span class="string">&quot;STUDENT&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-5-1"><a href="#步骤-5-1" class="headerlink" title="步骤 5"></a>步骤 5</h5><p>执行程序，输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page requested: HOME</span><br><span class="line">User is authenticated successfully.</span><br><span class="line">Displaying Home Page</span><br><span class="line">Page requested: STUDENT</span><br><span class="line">User is authenticated successfully.</span><br><span class="line">Displaying Student Page</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>API</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF 攻击</title>
    <url>/2021/05/15/20-34-57/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SSL安全证书</title>
    <url>/2021/05/15/21-13-24/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Token 认证的来龙去脉</title>
    <url>/2021/05/15/18-00-24/</url>
    <content><![CDATA[<p>概览：</p>
<p>1.为什么要用 Token？</p>
<p>2.需要设置有效期吗？</p>
<p>3.时序图表示    （1）登录    （2）业务请求    （3）Token 过期，刷新 Token</p>
<p>4.无状态 Token</p>
<p>5.分离认证服务</p>
<p>6.不受信的业务服务器</p>
<p>补充：java生成token方法</p>
<span id="more"></span>

<p> Token 认证的来龙去脉-原文链接：<a href="https://my.oschina.net/jamesfancy/blog/1613994">https://my.oschina.net/jamesfancy/blog/1613994</a></p>
<p>Token 无状态-原文链接：<a href="https://www.jianshu.com/p/7c34b78f1675">https://www.jianshu.com/p/7c34b78f1675</a></p>
<p>通常情况下，我们在讨论某个技术的时候，都是从问题开始。那么第一个问题：</p>
<h3 id="为什么要用-Token？"><a href="#为什么要用-Token？" class="headerlink" title="为什么要用 Token？"></a>为什么要用 Token？</h3><p>而要回答这个问题很简单——因为它能解决问题！</p>
<p>可以解决哪些问题呢？</p>
<ol>
<li>Token 完全由应用管理，所以它可以避开同源策略</li>
<li>Token 可以避免 <a href="https://www.oschina.net/action/GoToLink?url=http://www.cnblogs.com/shanyou/p/5038794.html">CSRF 攻击</a></li>
<li>Token 可以是无状态的，可以在多个服务间共享</li>
</ol>
<p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token  给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。如果这个 Token  在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p>
<p>于是，又一个问题产生了：需要为 Token 设置有效期吗？</p>
<h3 id="需要设置有效期吗？"><a href="#需要设置有效期吗？" class="headerlink" title="需要设置有效期吗？"></a>需要设置有效期吗？</h3><p>对于这个问题，我们不妨先看两个例子。一个例子是登录密码，一般要求定期改变密码，以防止泄漏，所以密码是有有效期的；另一个例子是安全证书。<strong>SSL 安全证书</strong>都有有效期，目的是为了解决吊销的问题，对于这个问题的详细情况，<a href="https://www.oschina.net/action/GoToLink?url=https://www.zhihu.com/question/20803288">来看看知乎的回答</a>。所以无论是从安全的角度考虑，还是从吊销的角度考虑，Token 都需要设有效期。</p>
<p>那么有效期多长合适呢？</p>
<p>只能说，根据系统的安全需要，尽可能的短，但也不能短得离谱——想像一下手机的自动熄屏时间，如果设置为 10  秒钟无操作自动熄屏，再次点亮需要输入密码，会不会疯？如果你觉得不会，那就亲自试一试，设置成可以设置的最短时间，坚持一周就好（不排除有人适应这个时间，毕竟手机厂商也是有用户体验研究的）。</p>
<p>然后新问题产生了，如果用户在正常操作的<strong>过程中</strong>，Token 过期失效了，要求用户重新登录……用户体验岂不是很糟糕？</p>
<p>为了解决在操作过程不能让用户感到 Token 失效这个问题，<u>有一种方案</u>是在服务器端保存 Token <strong>状态</strong>，用户每次操作都会<strong>自动刷新</strong>（推迟） Token 的过期时间——Session 就是采用这种策略来保持用户登录状态的。然而仍然存在这样一个问题，在<strong>前后端分离</strong>、<strong>单页 App</strong>  这些情况下，每秒种可能发起很多次请求，每次都去刷新过期时间会产生非常大的代价。如果 Token  的过期时间被持久化到数据库或文件，代价就更大了。所以通常为了提升效率，减少消耗，会把 Token 的过期时间保存在<strong>缓存或者内存</strong>中。</p>
<p>还有<u>另一种方案</u>，使用 <strong>Refresh Token</strong>，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 Token 的过期时间，一旦  Token 过期，就反馈给前端，前端使用 Refresh Token 申请一个全新 Token  继续使用。这种方案中，服务端只需要在客户端请求更新 Token 的时候对 Refresh Token  的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然 Refresh Token  也是有有效期的，但是这个有效期就可以长一点了，比如，以天为单位的时间。</p>
<p>相比session而言，Refresh token有以下几点优势</p>
<ol>
<li>服务端不需要缓存用户信息，减少服务器压力</li>
<li>token缓存在客户端，服务器重启，登录状态不会失效</li>
<li>session是浏览器特有的，app要支持会比较繁琐，token就没有这样的限制</li>
<li>易于扩展，存在多台服务器的情况下，使用负载均衡，第一次登录请求转发到A服务器，在A服务器的session中缓存了用户的登录信息，如果第二次请求转发到了B服务器，就丢失了登录状态。虽然可以使用redis等手段共享session，但token就简单很多，不同的服务器只需要使用相同的一段解密代码即可</li>
</ol>
<h3 id="时序图表示"><a href="#时序图表示" class="headerlink" title="时序图表示"></a>时序图表示</h3><p>使用 Token 和 Refresh Token 的时序图如下：</p>
<h5 id="1）登录"><a href="#1）登录" class="headerlink" title="1）登录"></a>1）登录</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="\uploads\upload.jpg" alt="clipboard.png" style="zoom:67%;" /></h5><img src="\uploads\token-p1.jpg" alt="clipboard.png" style="zoom:67%;" />

<h5 id="2）业务请求"><a href="#2）业务请求" class="headerlink" title="2）业务请求"></a>2）业务请求</h5><img src="\uploads\request.jpg" alt="clipboard.png" style="zoom:80%;" />

<h5 id="3）Token-过期，刷新-Token"><a href="#3）Token-过期，刷新-Token" class="headerlink" title="3）Token 过期，刷新 Token"></a>3）Token 过期，刷新 Token</h5><img src="D:\uploads\newToken.jpg" alt="clipboard.png" style="zoom:80%;" />

<p>上面的时序图中并未提到 Refresh Token 过期怎么办。不过很显然，Refresh Token 既然已经过期，就该要求用户重新登录了。</p>
<p>当然还可以把这个机制设计得更复杂一些，比如，Refresh Token 每次使用的时候，都更新它的过期时间，直到与它的创建时间相比，已经超过了非常长的一段时间（比如三个月），这等于是在相当长一段时间内允许 Refresh Token 自动续期。</p>
<p>到目前为止，Token 都是有状态的，即在服务端需要保存并记录相关属性。那说好的无状态呢，怎么实现？</p>
<h3 id="无状态-Token"><a href="#无状态-Token" class="headerlink" title="无状态 Token"></a>无状态 Token</h3><p>如果我们把所有状态信息都附加在 Token 上，服务器就可以不保存。但是服务端仍然需要认证 Token  有效。不过只要服务端能确认是自己签发的 Token，而且其信息未被改动过，那就可以认为 Token  有效——“签名”可以作此保证。平时常说的签名都存在一方签发，另一方验证的情况，所以要使用非对称加密算法。但是在这里，签发和验证都是同一方，所以对称加密算法就能达到要求，而对称算法比非对称算法要快得多（可达数十倍差距）。更进一步思考，对称加密算法除了加密，还带有还原加密内容的功能，而这一功能在对 Token 签名时并无必要——既然不需要解密，摘要（散列）算法就会更快。可以指定密码的散列算法，自然是 HMAC。</p>
<p>上面说了这么多，还需要自己去实现吗？不用！<a href="https://www.oschina.net/action/GoToLink?url=https://jwt.io/">JWT</a> 已经定义了详细的规范，而且有各种语言的若干实现。</p>
<p>不过在使用无状态 Token 的时候在服务端会有一些变化，服务端虽然不保存有效的 Token 了，却需要保存未到期却已注销的  Token。如果一个 Token 未到期就被用户主动注销，那么服务器需要保存这个被注销的 Token，以便下次收到使用这个仍在有效期内的  Token 时判其无效。有没有感到一点沮丧？</p>
<p>在前端可控的情况下（比如前端和服务端在同一个项目组内），可以协商：前端一但注销成功，就丢掉本地保存（比如保存在内存、LocalStorage 等）的 Token 和 Refresh Token。基于这样的约定，服务器就可以<strong>假设</strong>收到的 Token 一定是没注销的（因为注销之后前端就不会再使用了）。</p>
<p>如果前端不可控的情况，仍然可以进行上面的假设，但是这种情况下，需要尽量缩短 Token 的有效期，而且必须在用户主动注销的情况下让 Refresh Token 无效。这个操作<strong>存在一定的安全漏洞</strong>，因为用户会认为已经注销了，实际上在较短的一段时间内并没有注销。如果应用设计中，这点漏洞并不会造成什么损失，那采用这种策略就是可行的。</p>
<p>在使用无状态 Token 的时候，有两点需要注意：</p>
<ol>
<li>Refresh Token 有效时间较长，所以它应该在服务器端有状态，以增强安全性，确保用户注销时可控</li>
<li>应该考虑使用二次认证来增强敏感操作的安全性</li>
</ol>
<p>到此，关于 Token 的话题似乎差不多了——然而并没有，上面说的只是认证服务和业务服务集成在一起的情况，如果是分离的情况呢？</p>
<h3 id="分离认证服务"><a href="#分离认证服务" class="headerlink" title="分离认证服务"></a>分离认证服务</h3><p>当 Token 无状态之后，单点登录就变得容易了。前端拿到一个有效的 Token，它就可以在任何同一体系的服务上认证通过——只要它们使用同样的密钥和算法来认证 Token 的有效性。就像这样：</p>
<img src="\uploads\token-p4.jpg" alt="clipboard.png" style="zoom:80%;" />

<p>当然，如果 Token 过期了，前端仍然需要去认证服务更新 Token：</p>
<img src="\uploads\token-p5.jpg" alt="clipboard.png" style="zoom:80%;" />

<p>可见，虽然认证和业务分离了，实际即并没产生多大的差异。当然，这是建立在<strong>认证服务器信任业务服务器的前提</strong>下，因为认证服务器产生 Token 的密钥和业务服务器认证 Token 的密钥和算法相同。换句话说，业务服务器同样可以创建有效的 Token。</p>
<p>如果业务服务器不能被信任，该怎么办？</p>
<h3 id="不受信的业务服务器"><a href="#不受信的业务服务器" class="headerlink" title="不受信的业务服务器"></a>不受信的业务服务器</h3><p>遇到不受信的业务服务器时，很容易想到的办法是使用不同的密钥。认证服务器使用密钥1签发，业务服务器使用密钥2验证——这是典型非对称加密签名的应用场景。认证服务器自己使用私钥对 Token 签名，公开公钥。信任这个认证服务器的业务服务器保存公钥，用于验证签名。幸好，JWT 不仅可以使用 HMAC 签名，也可以使用  RSA（一种非对称加密算法）签名。</p>
<p>不过，当业务服务器已经不受信任的时候，<strong>多个业务服务器之间使用相同的 Token 对用户来说是不安全的</strong>。因为任何一个服务器拿到 Token 都可以仿冒用户去另一个服务器处理业务……悲剧随时可能发生。</p>
<p>为了防止这种情况发生，就需要在认证服务器产生 Token 的时候，把使用该 Token 的业务服务器的信息记录在 Token 中，这样当另一个业务服务器拿到这个 Token 的时候，发现它并不是自己应该验证的 Token，就可以直接拒绝。</p>
<p>现在，认证服务器不信任业务服务器，业务服务器相互也不信任，但前端是信任这些服务器的——如果前端不信任，就不会拿 Token 去请求验证。那么为什么会信任？可能是因为这些是同一家公司或者同一个项目中提供的若干服务构成的服务体系。</p>
<p>但是，前端信任不代表用户信任。如果 Token 没有携带用户隐私（比如姓名），那么用户不会关心信任问题。但如果 Token  含有用户隐私的时候，用户得关心信任问题了。这时候认证服务就不得不再啰嗦一些，当用户请求 Token  的时候，问上一句，你真的要授权给某某某业务服务吗？而这个“某某某”，用户怎么知道它是不是真的“某某某”呢？用户当然不知道，甚至认证服务也不知道，因为公钥已经公开了，任何一个业务都可以声明自己是“某某某”。</p>
<p>为了得到用户的信任，认证服务就不得不帮助用户来甄别业务服务。所以，认证服器决定不公开公钥，而是要求业务服务先申请注册并通过审核。只有通过审核的业务服务器才能得到认证服务为它创建的，仅供它使用的公钥。如果该业务服务泄漏公钥带来风险，由该业务服务自行承担。现在认证服务可以清楚的告诉用户，“某某某”服务是什么了。如果用户还是不够信任，认证服务甚至可以问，某某某业务服务需要请求 A、B、C 三项个人数据，其中 A 是必须的，不然它不工作，是否允许授权？如果你授权，我就把你授权的几项数据加密放在 Token 中……</p>
<p>废话了这么多，有没有似曾相识……对了，这类似开放式 API 的认证过程。开发式 API 多采用 OAuth 认证，而关于 OAuth 的探讨资源非常丰富，这里就不深究了。</p>
<h4 id="java生成token方法"><a href="#java生成token方法" class="headerlink" title="java生成token方法"></a>java生成token方法</h4><h5 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h5><p>网上找到的大部分资料都是使用JWT来生成token，JWT生成的token包含三部分</p>
<ol>
<li><p>header：包含token类型和加密算法</p>
</li>
<li><p>payload：存放自定义数据</p>
</li>
<li><p>signature：对前面两部分的签名，防止篡改数据\r\n\r\n用JWT生成的token是很长的一串字符串，用Base64进行编码，可以解码出原数据，注意不能放一些私密信息，比如用户密码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\r\n<span class="selector-class">.eyJleHBpcmVUaW1lIjoxNTQ5NTU0NDUyLCJ1c2VyTmFtZSI6IuacveacqCIsInVzZXJJZCI6IjY2NiJ9</span>\r\n<span class="selector-class">.fiQKWuMTWbkfQ3dOozoJr13pJSmKnc5El4EBnKyU42o</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>上面这很长的一串就是用JWT生成的token，可以感受一下这个长度。客户端的每次请求都要带上这么一大串，服务端的每次响应都要返回这么一大串，我个人是难以接受的。所以我用了下面那种方法</p>
<h5 id="AES（Advanced-Encryption-Standard）"><a href="#AES（Advanced-Encryption-Standard）" class="headerlink" title="AES（Advanced Encryption Standard）"></a>AES（Advanced Encryption Standard）</h5><p>token本质是一段加密的字符串，包含登录用户的一些信息，通过解密可以获取这些信息，所以理论上任何安全的加密解密手段都可以用来生成token<br> 高级加密标准AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。AES采用对称加密，相比于非对称加密，对称加密效率更快</p>
<ul>
<li>对称加密：加密和解密使用相同的密钥。适用于单方面的加密解密，密钥不能泄露</li>
<li>非对称加密：使用公钥加密，私钥解密。适用于一方加密，另一方解密，比如前后端的数据传输，可以在客户端使用公钥对数据进行加密，在服务端使用密钥进行解密，增强数据安全性<br> token的加密解密都在服务端进行，所以使用对称加密的AES算法即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EmaZUvyM9aabQ2Jmo6THJ&#x2F;r3&#x2F;e2xAjpRmoA5TzvuR4I&#x3D;</span><br></pre></td></tr></table></figure>

<p>上面这一小串就是用AES生成的token了，是不是清爽了很多，而且没有密钥无法解密，相比JWT生成的token，AES生成的token携带的数据更安全</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Http无状态？</title>
    <url>/2021/05/15/21-13-48/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>同源策略</title>
    <url>/2021/05/15/20-34-29/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>前后端项目之王者荣耀爬虫</title>
    <url>/2021/05/11/14-51-21/</url>
    <content><![CDATA[<p>概览：</p>
<p>1.flask框架模板        2.WSGI        3.反爬虫机制和破解方法汇总    </p>
<p>4.raise_for_status()        5.bind()        6.Python f 字符串教程    </p>
<span id="more"></span>



<p>题外话：</p>
<p>今天花了1小时在车联网课程大作业上，了解车联网的技术和当前面临的挑战。</p>
<p>随后回归前端学习。</p>
<h3 id="前后端项目之王者荣耀爬虫"><a href="#前后端项目之王者荣耀爬虫" class="headerlink" title="前后端项目之王者荣耀爬虫"></a>前后端项目之王者荣耀爬虫</h3><h4 id="1-flask框架："><a href="#1-flask框架：" class="headerlink" title="1.flask框架："></a>1.flask框架：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">9000</span>)</span><br></pre></td></tr></table></figure>

<p>​            第1行，引入Flask类，Flask类实现了一个WSGI应用<br>​            第2行，app是Flask的实例，它接收包或者模块的名字作为参数，但一般都是传递__name__。让flask.helpers.get_root_path函数通过传入这个名字确定程序的根目录，以便获得静态文件和模板文件的目录。<br>​            第4~6行，使用app.route装饰器会将URL和执行的视图函数的关系保存到app.url_map属性上。处理URL和视图函数的关系的程序就是路由，这里的视图函数就是hello_world。<br>​            第8行，使用这个判断可以保证当其他文件引用这个文件的时候（例如“from hello import app”）不会执行这个判断内的代码，也就是不会执行app.run函数。<br>​            第9行，执行app.run就可以启动服务了。默认Flask只监听虚拟机的本地127.0.0.1这个地址，端口为5000。而我们对虚拟机做的端口转发端口是9000，所以需要制定host和port参数，0.0.0.0表示监听所有地址，这样就可以在本机访问了。<br>​            服务器启动后，会调用werkzeug.serving.run_simple进入轮询，默认使用单进程单线程的werkzeug.serving.BaseWSGIServer处理请求，<br>​            实际上还是使用标准库BaseHTTPServer.HTTPServer，通过select.select做0.5秒的“while TRUE”的事件轮询。<br>​            当我们访问“<a href="http://127.0.0.1:9000/%E2%80%9D,%E9%80%9A%E8%BF%87app.url_map%E6%89%BE%E5%88%B0%E6%B3%A8%E5%86%8C%E7%9A%84%E2%80%9C/%E2%80%9D%E8%BF%99%E4%B8%AAURL%E6%A8%A1%E5%BC%8F,%E5%B0%B1%E6%89%BE%E5%88%B0%E4%BA%86%E5%AF%B9%E5%BA%94%E7%9A%84hello_world%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E2%80%9Chello">http://127.0.0.1:9000/”,通过app.url_map找到注册的“/”这个URL模式,就找到了对应的hello_world函数执行，返回“hello</a> world!”,状态码为200。<br>​            如果访问一个不存在的路径，如访问“<a href="http://127.0.0.1:9000/a%E2%80%9D,Flask%E6%89%BE%E4%B8%8D%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%90%91%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%94%E5%9B%9E%E2%80%9CNot">http://127.0.0.1:9000/a”,Flask找不到对应的模式，就会向浏览器返回“Not</a> Found”，状态码为404</p>
<p>​        原文链接：<a href="https://blog.csdn.net/christopherchen/article/details/54636846">https://blog.csdn.net/christopherchen/article/details/54636846</a></p>
<h4 id="2-WSGI"><a href="#2-WSGI" class="headerlink" title="2.WSGI"></a>2.WSGI</h4><p>了解了HTTP协议和HTML文档，我们其实就明白了一个Web应用的本质就是：</p>
<ol>
<li>浏览器发送一个HTTP请求；</li>
<li>服务器收到请求，生成一个HTML文档；</li>
<li>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</li>
<li>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</li>
</ol>
<p>所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。</p>
<p>如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p>
<p>正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。</p>
<p>这个接口就是WSGI：Web Server Gateway Interface。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span>(<span class="params">environ, start_response</span>):</span></span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>application()</code>函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p>
<ul>
<li>environ：一个包含所有HTTP请求信息的<code>dict</code>对象；</li>
<li>start_response：一个发送HTTP响应的函数。</li>
</ul>
<p>在<code>application()</code>函数中，调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br></pre></td></tr></table></figure>

<p>就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次<code>start_response()</code>函数。<code>start_response()</code>函数接收两个参数，一个是HTTP响应码，一个是一组<code>list</code>表示的HTTP Header，每个Header用一个包含两个<code>str</code>的<code>tuple</code>表示。</p>
<p>通常情况下，都应该把<code>Content-Type</code>头发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>
<p>然后，函数的返回值<code>&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;</code>将作为HTTP响应的Body发送给浏览器。</p>
<p>有了WSGI，我们关心的就是如何从<code>environ</code>这个<code>dict</code>对象拿到HTTP请求信息，然后构造HTML，通过<code>start_response()</code>发送Header，最后返回Body。</p>
<p>整个<code>application()</code>函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p>
<p>不过，等等，这个<code>application()</code>函数怎么调用？如果我们自己调用，两个参数<code>environ</code>和<code>start_response</code>我们没法提供，返回的<code>str</code>也没法发给浏览器。</p>
<p>所以<code>application()</code>函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的<code>application()</code>函数真的可以把HTML输出到浏览器，所以，要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。</p>
<p>好消息是Python内置了一个WSGI服务器，这个模块叫wsgiref，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用</p>
<p>……</p>
<p>原文链接：<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057027806560">https://www.liaoxuefeng.com/wiki/897692888725344/923057027806560</a></p>
<h4 id="3-反爬虫机制和破解方法汇总"><a href="#3-反爬虫机制和破解方法汇总" class="headerlink" title="3.反爬虫机制和破解方法汇总"></a>3.反爬虫机制和破解方法汇总</h4><h6 id="什么是爬虫和反爬虫？"><a href="#什么是爬虫和反爬虫？" class="headerlink" title="什么是爬虫和反爬虫？"></a>什么是爬虫和反爬虫？</h6><ul>
<li><strong>爬虫</strong>：使用任何技术手段，批量获取网站信息的一种方式。</li>
<li><strong>反爬虫</strong>：使用任何技术手段，阻止别人批量获取自己网站信息的一种方式。</li>
</ul>
<h6 id="常见的反爬虫机制"><a href="#常见的反爬虫机制" class="headerlink" title="常见的反爬虫机制"></a>常见的反爬虫机制</h6><ul>
<li><strong>通过UA 识别爬虫</strong> 有些爬虫的UA(UserAgent)是特殊的，与正常浏览器的不一样，可通过识别特征UA，直接封掉爬虫请求</li>
<li><strong>设置IP访问频率，如果超过一定频率，弹出验证码</strong> 如果输入正确的验证码，则放行，如果没有输入，则拉入禁止一段时间，如果超过禁爬时间，再次出发验证码，则拉入黑名单。当然根据具体的业务，为不同场景设置不同阈值，比如登陆用户和非登陆用户，请求是否含有refer。</li>
<li><strong>通过并发识别爬虫</strong> 有些爬虫的并发是很高的，统计并发最高的IP，加入黑名单（或者直接封掉爬虫IP所在C段）</li>
<li><strong>请求的时间窗口过滤统计</strong> 爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近12次访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间，如果间隔时间很长判断不是爬虫，清除时间窗口，如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码</li>
<li><strong>限制单个ip/api token的访问量</strong> 比如15分钟限制访问页面180次，具体标准可参考一些大型网站的公开api，如twitter api，对于抓取用户公开信息的爬虫要格外敏感</li>
<li><strong>识别出合法爬虫</strong> 对http头agent进行验证，是否标记为、百度的spider，严格一点的话应该判别来源IP是否为、baidu的爬虫IP，这些IP在网上都可以找到。校验出来IP不在白名单就可以阻止访问内容。</li>
<li><strong>蜜罐资源</strong> 爬虫解析离不开正则匹配，适当在页面添加一些正常浏览器浏览访问不到的资源，一旦有ip访问，过滤下头部是不是搜素引擎的蜘蛛，不是就可以直接封了。比如说隐式链接。</li>
</ul>
<h6 id="破解反爬虫机制的几种方法"><a href="#破解反爬虫机制的几种方法" class="headerlink" title="破解反爬虫机制的几种方法"></a>破解反爬虫机制的几种方法</h6><ul>
<li><strong>策略1</strong>：<strong>设置下载延迟</strong>，比如数字设置为5秒，越大越安全</li>
<li><strong>策略2</strong>：<strong>禁止Cookie</strong>，某些网站会通过Cookie识别用户身份，禁用后使得服务器无法识别爬虫轨迹</li>
<li><strong>策略3</strong>：<strong>使用user agent池</strong>。也就是每次发送的时候随机从池中选择不一样的浏览器头信息，防止暴露爬虫身份</li>
<li><strong>策略4</strong>：<strong>使用IP池</strong>，这个需要大量的IP资源，可以通过抓取网上免费公开的IP建成自有的IP代理池。</li>
<li><strong>策略5</strong>：<strong>分布式爬取</strong>，这个是针对大型爬虫系统的，实现一个分布式的爬虫，主要为以下几个步骤：  1、基本的http抓取工具，如scrapy；  2、避免重复抓取网页，如Bloom Filter；  3、维护一个所有集群机器能够有效分享的分布式队列；  4、将分布式队列和Scrapy的结合；  5、后续处理，网页析取(如python-goose)，存储(如Mongodb)。</li>
<li><strong>策略6：模拟登录—浏览器登录的爬取</strong> 设置一个cookie处理对象，它负责将cookie添加到http请求中，并能从http响应中得到cookie，向网站登录页面发送一个请求Request, 包括登录url，POST请求的数据，Http header利用urllib2.urlopen发送请求，接收WEB服务器的Response。</li>
</ul>
<h6 id="3-1并发用户数：同时与服务器进行交互在线用户量"><a href="#3-1并发用户数：同时与服务器进行交互在线用户量" class="headerlink" title="3.1并发用户数：同时与服务器进行交互在线用户量"></a>3.1并发用户数：同时与服务器进行交互在线用户量</h6><p>​    并发用户数量，有两种常见的错误观点。一种错误观点是把并发用户数量理解为使用系统的全部用户的数量，理由是这些用户可能同时使用系统；还有一种比较接近正确的观点是把用户在线数量理解为并发用户数量。</p>
<p>  实际上，在线用户不一定会和其他用户发生并发，例如正在浏览网页的用户，对服务器是没有任何影响的。但是，用户在线数量是统计并发用户数量的主要依据之一。</p>
<p>​    并发主要是针对服务器而言，是否并发的关键是看用户操作是否对服务器产生了影响。因此，并发用户数量的正确理解为：在同一时段与服务器进行了交互的在线用户数量。这些用户的最大特征是和服务器产生了交互，这种交互既可以是单向的传输数据，也可以是双向的传送数据。</p>
<h4 id="4-raise-for-status"><a href="#4-raise-for-status" class="headerlink" title="4.raise_for_status()"></a>4.<a href="https://blog.csdn.net/weixin_43360707/article/details/101034944">raise_for_status()</a></h4><p>能够判断返回的Response类型状态是不是200。如果是200，他将表示返回的内容是正确的，如果不是200，他就会产生一个HttpError的异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		r = requests.get(url, timeout = <span class="number">30</span>)</span><br><span class="line">		r.raise_for_status()</span><br><span class="line">		r.encoding = r.apparent_encoding</span><br><span class="line">		<span class="keyword">return</span> r.text</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		<span class="keyword">return</span> “产生异常”</span><br></pre></td></tr></table></figure>

<p>这个代码中我们用r.raise_for_status()方法，它就可以有效的判断网络连接的状态。如果网连接出现错误，那么它就会用try-except来获取一个异常。而这个异常，在异常部分，我们用了一句 return “产生异常” 来表示，我们捕获到了这个异常，所以这样一个通用代码框架可以有效的处理，我们在访问或爬取网页过程中，它可能出现的一些错误，或者是网络不稳定造成的一些现象</p>
<h4 id="5-bind"><a href="#5-bind" class="headerlink" title="5.bind()"></a>5.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind()</a></h4><p>Function.prototype.bind()</p>
<p><code>**bind()**</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unboundGetX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(unboundGetX()); <span class="comment">// The function gets invoked at the global scope</span></span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGetX = unboundGetX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundGetX());</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>thisArg : 调用绑定函数时作为 <code>this</code> 参数传递给目标函数的值。 如果使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a>运算符构造绑定函数，则忽略该值。当使用 <code>bind</code> 在 <code>setTimeout</code> 中创建一个函数（作为回调提供）时，作为 <code>thisArg</code> 传递的任何原始值都将转换为 <code>object</code>。如果 <code>bind</code> 函数的参数列表为空，或者<code>thisArg</code>是<code>null</code>或<code>undefined</code>，执行作用域的 <code>this</code> 将被视为新函数的 <code>thisArg</code>。</p>
<p>arg1、arg2 : 当目标函数被调用时，被预置入绑定函数的参数列表中的参数</p>
<p>返回值：返回一个原函数的拷贝，并拥有指定的 <strong><code>this</code></strong> 值和初始参数。</p>
<p><strong>bind()</strong> 函数会创建一个新的<strong>绑定函数</strong>（<strong>bound function</strong>，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用<strong>绑定函数</strong>通常会导致执行<strong>包装函数</strong>。<br> <strong>绑定函数</strong>具有以下内部属性：</p>
<ul>
<li><strong>[[BoundTargetFunction]]</strong> - 包装的函数对象</li>
<li><strong>[[BoundThis]]</strong> - 在调用包装函数时始终作为 <strong>this</strong> 值传递的值。</li>
<li><strong>[[BoundArguments]]</strong> - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。</li>
<li><strong>[[Call]]</strong> - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个<strong>this</strong>值和一个包含通过调用表达式传递给函数的参数的列表。</li>
</ul>
<p>当调用绑定函数时，它调用 <strong>[[BoundTargetFunction]]</strong> 上的内部方法 **[[Call]]**，就像这样 <strong>Call(*boundThis*, *args*)<strong>。其中，</strong>boundThis</strong> 是 <strong>[[BoundThis]]<strong>，</strong>args</strong> 是 <strong>[[BoundArguments]]</strong> 加上通过函数调用传入的参数列表。</p>
<p>绑定函数也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 <code>this</code> 值会被忽略，但前置参数仍会提供给模拟函数。</p>
<h4 id="6-Python-f-字符串教程"><a href="#6-Python-f-字符串教程" class="headerlink" title="6.Python f 字符串教程"></a>6.<a href="https://geek-docs.com/python/python-tutorial/python-fstring.html">Python f 字符串教程</a></h4><p>f 字符串的前缀为<code>f</code>，并使用<code>&#123;&#125;</code>括号评估值。</p>
<p>在冒号后指定用于类型，填充或对齐的格式说明符； 例如：<code>f&#39;&#123;price:.3&#125;&#39;</code>，其中<code>price</code>是变量名。</p>
<p>举例：Python 中的字符串格式设置选项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s is %d years old&#x27;</span> % (name, age))//这是最旧的选项。 它使用%运算符和经典字符串格式指定，例如%s和%d。</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; is &#123;&#125; years old&#x27;</span>.<span class="built_in">format</span>(name, age))//从 Python <span class="number">3.0</span> 开始，<span class="built_in">format</span>()函数被引入以提供高级格式化选项。</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;age&#125;</span> years old&#x27;</span>)//从 Python <span class="number">3.6</span> 开始，Python f 字符串可用。 该字符串具有f前缀，并使用&#123;&#125;评估变量</span><br><span class="line">//输出是一样的 Peter <span class="keyword">is</span> <span class="number">23</span> years old</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//可以将表达式放在&#123;&#125;括号之间</span><br><span class="line">b= <span class="number">3</span></span><br><span class="line">a= <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(f&#123;b * a&#125;<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">//输出是36</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//可以使用 f 字符串中的字典</span><br><span class="line">user = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>: <span class="string">&#x27;gardener&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span> is a <span class="subst">&#123;user[<span class="string">&#x27;occupation&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">//John Doe <span class="keyword">is</span> a gardener</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//可以使用多行字符串。</span><br><span class="line">name = <span class="string">&#x27;John Doe&#x27;</span></span><br><span class="line">age = <span class="number">32</span></span><br><span class="line">occupation = <span class="string">&#x27;gardener&#x27;</span></span><br><span class="line">msg = (</span><br><span class="line">    <span class="string">f&#x27;Name: <span class="subst">&#123;name&#125;</span>\n&#x27;</span></span><br><span class="line">    <span class="string">f&#x27;Age: <span class="subst">&#123;age&#125;</span>\n&#x27;</span></span><br><span class="line">    <span class="string">f&#x27;Occupation: <span class="subst">&#123;occupation&#125;</span>&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line">//Name: John Doe</span><br><span class="line">//Age: <span class="number">32</span></span><br><span class="line">//Occupation: gardener</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//可以在 f 字符串中调用函数</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymax</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Max of <span class="subst">&#123;a&#125;</span> and <span class="subst">&#123;b&#125;</span> is <span class="subst">&#123;mymax(a, b)&#125;</span>&#x27;</span>)</span><br><span class="line">//Max of <span class="number">3</span> <span class="keyword">and</span> <span class="number">4</span> <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//也接受对象。 对象必须定义了`__str__()`或`__repr__()`魔术函数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, occupation</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.occupation = occupation</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is a <span class="subst">&#123;self.occupation&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">u = User(<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;gardener&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;u&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">//John Doe <span class="keyword">is</span> a gardener</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//示例格式化日期时间</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;now:%Y-%m-%d %H:%M&#125;</span>&#x27;</span>)</span><br><span class="line">//该示例显示格式化的当前日期时间。 日期时间格式说明符位于&lt;colon&gt;：&lt;/colon&gt;字符之后。2019-05-11 22:39</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//格式化浮点数</span><br><span class="line">//浮点值的后缀为f。 我们还可以指定精度：小数位数。 精度是一个点字符后的值。</span><br><span class="line">val = <span class="number">12.3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;val:<span class="number">.2</span>f&#125;</span>&#x27;</span>)//<span class="number">12.30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;val:<span class="number">.5</span>f&#125;</span>&#x27;</span>)//<span class="number">12.30000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//格式化宽度</span><br><span class="line">//宽度说明符设置值的宽度。 如果该值短于指定的宽度，则该值可以用空格或其他字符填充。</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x:02&#125;</span> <span class="subst">&#123;x*x:<span class="number">3</span>&#125;</span> <span class="subst">&#123;x*x*x:<span class="number">4</span>&#125;</span>&#x27;</span>)</span><br><span class="line">//该示例打印三列，每个列都有一个预定义的宽度。 第一列使用 <span class="number">0</span> 填充较短的值。</span><br><span class="line">/*</span><br><span class="line">01   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">02   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line">03   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line">04  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line">05  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line">06  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line">07  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line">08  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line">09  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span>*/</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//字符串对齐字符串</span><br><span class="line">//默认情况下，字符串在左边对齐。 我们可以使用`&gt;`字符来对齐右侧的字符串。 `&gt;`字符在冒号后面。</span><br><span class="line">s1 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;ab&#x27;</span></span><br><span class="line">s3 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">s4 = <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;s1:&gt;<span class="number">10</span>&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;s2:&gt;<span class="number">10</span>&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;s3:&gt;<span class="number">10</span>&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;s4:&gt;<span class="number">10</span>&#125;</span>&#x27;</span>)</span><br><span class="line">/*</span><br><span class="line">         a</span><br><span class="line">        ab</span><br><span class="line">       abc</span><br><span class="line">      abcd</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//字符串数字符号</span><br><span class="line">//数字可以具有各种数字符号，例如十进制或十六进制。</span><br><span class="line">a = <span class="number">300</span></span><br><span class="line"><span class="comment"># hexadecimal  16进制  -&gt;12c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a:x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># octal    10进制  -&gt;454</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a:o&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scientific   -&gt;3.000000e+02</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a:e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-MDN</title>
    <url>/2021/05/16/00-01-43/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Js小红书第一章阅读</title>
    <url>/2021/06/09/15-07-35/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue优化方式</title>
    <url>/2021/09/13/19-52-58/</url>
    <content><![CDATA[<h1 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h1><h3 id="避免响应所有数据"><a href="#避免响应所有数据" class="headerlink" title="避免响应所有数据"></a>避免响应所有数据</h3><p>不要把所有数据都放到data中，data中的数据都会增加getter和setter，而且会收集watcher，这样还占内存，不需要响应式的数据我们可以直接定义在实例上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;&#125;,</span><br><span class="line">        data:()&#x3D;&gt;(&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;),</span><br><span class="line">        beforeCreate:function()&#123;</span><br><span class="line">            this.timer&#x3D;null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>Vue 推荐在绝大多数情况下使用 template 来创建你的HTML。但是现实的业务场景中经常会遇到根据用户权限判断，显示不同的按钮。</p>
<h5 id="什么是函数式组件："><a href="#什么是函数式组件：" class="headerlink" title="什么是函数式组件："></a>什么是函数式组件：</h5><p>函数式组价属于渲染函数能够使用 JavaScript 的完全编程能力。没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法，它只接收一些 prop 的函数。</p>
<p>函数式组件是一个不包含状态和实例的组件，简单的说，就是函数不支持响应式，并且不能通过this关键字引用自己。因为函数式组件没有状态，所以它不需要像Vue的响应式系统一样需要经过额外的初始化，这样就可以避免相关操作带来的性能消耗。当然函数式组件仍然会对相应的变化做出响应式改变，比如新传入新的 props ,但是在组件本身中，它无法知道数据何时发生了更改，因为它不维护自己的状态。很多场景非常适合使用函数式组件：</p>
<ul>
<li>一个简单的展示组件  ，也就是所谓的dumb组件。例如 buttons、pills、tags、cards 等，甚至整个页面都是静态文本，比如About页面。</li>
</ul>
<h5 id="如何创建一个函数式组件"><a href="#如何创建一个函数式组件" class="headerlink" title="如何创建一个函数式组件"></a>如何创建一个函数式组件</h5><p>首先将组件标记为 functional , 这意味着它无状态、无实例。</p>
<p>一个函数式组件就像这样：</p>
<p>Vue.component(“my-component”,{</p>
<p>​    functional:true,</p>
<p>​    render : function(createElement , context ){</p>
<p>​        //…    </p>
<p>​    }</p>
<p>})</p>
<p>context 中包含以下字段的对象：</p>
<ul>
<li>props : 提供所有 prop 的对象</li>
<li>children : VNode子节点的数组</li>
<li>slots : 一个函数，返回了包含所有插槽的对象</li>
<li>scopedSlots : 一个暴露传入的作用域槽的对象。也以函数形式暴露普通插槽。</li>
<li>data : 传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</li>
<li>parent ： 对父组件的引用</li>
<li>listeners ： 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是data.on的一个别名</li>
<li>injuctions : 如果使用了 inject 选项，则该对象包含了应当被注入的property</li>
</ul>
<h5 id="为什么使用函数式组件"><a href="#为什么使用函数式组件" class="headerlink" title="为什么使用函数式组件"></a>为什么使用函数式组件</h5><p>第一，因为函数式组件只是函数，渲染开销会低很多。</p>
<p>第二，更灵活，它能根据传入 prop 的值来代为渲染更具体的组件</p>
<h5 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h5><p>假如我们封装一套按钮组件，通过后台返回的type进行渲染，首先可能想到的是 v-if 实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;success&#x27;&quot;</span>&gt;</span>success<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;error&#x27;&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;warm&#x27;&quot;</span>&gt;</span>warm<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>default<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样不好扩展 若想扩展就要v-else-if</p>
<p>这里我们就可以用到函数式组件了 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> typeButton = &#123;</span><br><span class="line">	functional:<span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params">h,&#123;props&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = props</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#123;</span> <span class="attr">type</span> &#125;&gt;</span>&#123;type&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的函数式组件 根据type 的值不同渲染出不同的样式的按钮</p>
<h5 id="业务场景下的函数式组件"><a href="#业务场景下的函数式组件" class="headerlink" title="业务场景下的函数式组件"></a>业务场景下的函数式组件</h5><p>通过【绑定状态】、【操作状态】进行不同按钮的渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Confirm = &#123;</span><br><span class="line">	functional : <span class="literal">true</span>,</span><br><span class="line">    render (h,&#123;parent,props,listeners&#125;)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; vo &#125; = props , &#123; bindStatus &#125; = vo</span><br><span class="line">        <span class="keyword">const</span> btnText = [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;同意绑定&#x27;</span>,<span class="string">&#x27;解绑&#x27;</span>,<span class="string">&#x27;同意解绑&#x27;</span>,<span class="string">&#x27;取消添加&#x27;</span>][bindStatus]</span><br><span class="line">        <span class="keyword">const</span> btnClick = <span class="function">() =&gt;</span> listeners.click(vo,doState)</span><br><span class="line">        <span class="keyword">return</span> doState &gt; <span class="number">0</span>?&lt;el-button type=&#x27;text&#x27; onClick=&#123;btnClick&#125;&gt;&#123;btnText&#125;&lt;el-button&gt;:&#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区分-computed-和-watch-使用场景"><a href="#区分-computed-和-watch-使用场景" class="headerlink" title="区分 computed 和 watch 使用场景"></a>区分 computed 和 watch 使用场景</h5><p>computed 是计算属性，依赖其他属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值</p>
<p>watch更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。当我们需要进行数值计算，并且依赖于其他数据时，应该使用 computed ， 因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算。当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。</p>
<h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1>]]></content>
  </entry>
  <entry>
    <title>Vue-官方文档</title>
    <url>/2021/05/16/00-02-22/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>浏览器安全</title>
    <url>/2021/05/20/18-39-59/</url>
    <content><![CDATA[<p>1.关于浏览器的安全问题（前端有哪些危险）</p>
<p>2.防御XSS攻击的方法</p>
<p>3.cookie里面有个字段httponly是干嘛的</p>
<p>4.CSRF的攻击流程</p>
<p>5.具体如何防御CSRF攻击</p>
<p>6.CSRFtoken可以被窃取吗</p>
<p>7.那CSRFtoken是不是白做了</p>
<p>8.referer了解这个字段吗</p>
<p>9.黑客怎么样利用这个cookie的，请求是怎么仿造的</p>
<p>10.cookie怎么发送到服务端的详细过程</p>
<p>11.CSRFtoken能放到cookie里面吗</p>
]]></content>
  </entry>
  <entry>
    <title>牛客华为-字符串类题-js</title>
    <url>/2021/05/10/01-30-15/</url>
    <content><![CDATA[<p>概览（共9题-题目）：<br>1.字符串最后一个单词的长度（较难）        2.计算某字母出现次数（较难）        3.字符串分隔（较难）<br>4.进制转换（中等）        5.字符个数统计（中等）        6.数字颠倒（简单）        7.字符串反转（简单）<br>8.句子逆序（较难）        9.字符串排序（中等）</p>
<span id="more"></span>

<h2 id="字符串类型题-js"><a href="#字符串类型题-js" class="headerlink" title="字符串类型题  js"></a>字符串类型题  js</h2><h4 id="T1-字符串最后一个单词的长度（较难）"><a href="#T1-字符串最后一个单词的长度（较难）" class="headerlink" title="T1.字符串最后一个单词的长度（较难）"></a>T1.字符串最后一个单词的长度（较难）</h4><p>题目描述：计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。<br>输入：输入一行，代表要计算的字符串，非空，长度小于5000。<br>输出：输出一个整数，表示输入字符串最后一个单词的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1：简单解法，但不满足具体题意</span></span><br><span class="line"><span class="keyword">let</span> s = readline().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s[s.length-<span class="number">1</span>].length) </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2：满足题目描述具体解法</span></span><br><span class="line"><span class="keyword">let</span> strArr = readline().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(strArr.length &amp;&amp; strArr.length &lt; <span class="number">5000</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strArr[strArr.length-<span class="number">1</span>].length)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;输入应非空&amp;&amp;字符串长度小于5000&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li><p>之前好像没有用过readline()函数完全没有映像（牛客自己的）；split()函数复习（用split(‘ ‘)把字符串按照空格分成数组）；输出函数console.log()好几天没写差点忘了差点写print哈哈哈（这个在牛客其实可以）；</p>
</li>
<li><p>JavaScript输出：JavaScript，没有任何打印或者输出的函数</p>
</li>
<li><p>JavaScript显示数据：JavaScript可以通过不同的方式来输出数据：</p>
<ul>
<li>使用window.alert()弹出警告框。</li>
<li>使用document.write()方法将内容写到HTML文档中</li>
<li>使用innerHTML写入到HTML元素</li>
<li>使用console.log()写入到浏览器的控制台</li>
</ul>
</li>
<li><p>（Object一共有两类原生方法，一是本身的方法，二是实例方法）</p>
<ul>
<li><p>所谓本身的方法就是直接定义在Object对象的方法。<code>Object.print = function(o)&#123;console.log(o) &#125;;</code>print方法是直接定义在Object对象上的</p>
</li>
<li><p>所谓实例方法就是定义在Object原型对象 Object.prototype 上的方法。它可以被Object实例直接使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.print &#x3D; function () &#123;</span><br><span class="line">	console.log(this) ;</span><br><span class="line">&#125;;</span><br><span class="line">let obj &#x3D; new Object();</span><br><span class="line">obj.print()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="T2-计算某字母出现次数（较难）"><a href="#T2-计算某字母出现次数（较难）" class="headerlink" title="T2.计算某字母出现次数（较难）"></a>T2.计算某字母出现次数（较难）</h4><p>题目描述：写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字母，然后输出输入字符串                    中该字母的出现次数。不区分大小写，字符串长度小于500。<br>输入：第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字母。<br>输出：输出输入字符串中含有该字符的个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br><span class="line"><span class="keyword">let</span> line = readline().toLowerCase()</span><br><span class="line"><span class="keyword">let</span> strget = readline().toLowerCase()</span><br><span class="line"><span class="built_in">console</span>.log(line.split(<span class="string">&#x27;&#x27;</span>).filter(<span class="function"><span class="params">e</span>=&gt;</span>e===strget).length)</span><br><span class="line"><span class="comment">//这里的console.log可以换成print</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2</span></span><br><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> a = readline().toLowerCase()</span><br><span class="line">    <span class="keyword">let</span> strA = line.toLowerCase()</span><br><span class="line">    <span class="keyword">for</span> (chart <span class="keyword">of</span> strA)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a === chart)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li><p>不区分大小写：将用来比较的字符串都换成小写/大写；</p>
</li>
<li><p>直接对一个字符串进行分割、过滤、求长度；</p>
</li>
<li><p>filter函数：<code>**filter()**</code>方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </p>
</li>
<li><p>Node.js的readline()：模块提供了一个接口，用于一次一行地读取可读流例如（ process.stdin）中的数据。</p>
</li>
<li><p>可读流：是对数据来源的一种抽象。可读流的例子包括：<br>客户端的HTTP响应、服务器的HTTP请求、fs的读取流、zlib流、crypto流、TCP socket、子进程 stdout 与 stderr、process.stdin</p>
</li>
<li><p>由for(…… of…… ) 引出的关于字符串遍历的几种方法的收集：</p>
<ul>
<li> for循环：要遍历字符串的所有字符，我们可以使用一个普通的for循环，并使用一个循环计数器（i）来对字符串索引遍历</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Buzz&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>for…in…：存在一种特殊的循环形式，变量 i 自动接收索引，以便可以使用来访问每个字符<code>str[i]</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> str)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>for…of…：使用<code>for item of str</code>。变量<code>item</code>直接接收字符，因此不必使用索引。如果代码不需要每个字符的索引值，则此循环格式甚至更简单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(char);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="T3-字符串分隔（较难）"><a href="#T3-字符串分隔（较难）" class="headerlink" title="T3.字符串分隔（较难）"></a>T3.字符串分隔（较难）</h4><p>题目描述：连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。<br>输入：连续输入字符串(输入多次,每个字符串长度小于100)<br>输出：输出到长度为8的新字符串数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1，先加7个0，然后只保留能整除8的部分的字符串，然后每8个print一次</span></span><br><span class="line"><span class="keyword">while</span>(str = readline())&#123;</span><br><span class="line">    str+=<span class="string">&#x27;0000000&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">Math</span>.floor(str.length/<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        print(str.substring(i*<span class="number">8</span>,(i+<span class="number">1</span>)*<span class="number">8</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2,直接把传进来的一行处理了，从头到尾遍历字符串line，把它加进str,大于7（8）时就输出，然后str清零，遍历完了之后用if语句看str是不是空，不是的话加0到8个输出。</span></span><br><span class="line"><span class="keyword">while</span>((line=readline()))&#123;</span><br><span class="line">    <span class="keyword">let</span> str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;line.length;i++)&#123;</span><br><span class="line">        str=str+line[i];</span><br><span class="line">        <span class="keyword">if</span>(str.length&gt;<span class="number">7</span>)&#123;</span><br><span class="line">            print(str);</span><br><span class="line">            str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(str.length&lt;<span class="number">8</span>) str+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        print(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li>题目‘连续输入字符串’，解题时用<code>while(line = readline())&#123; &#125;</code></li>
<li><code>**Math.floor()**</code>为向下取整。学习<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a>，以下为个人觉得需要记住的：<ul>
<li>Math.abs(x)  绝对值</li>
<li>Math.random()  0 到 1 之间的伪随机数</li>
<li>Math.round(x)  返回四舍五入后的整数</li>
<li>Math.ceil(x)  一个数向上取整后的值</li>
<li>Math.floor(x)  一个数向下取整后的值</li>
<li>Math.log(x)  自然对数</li>
<li>Math.lnx  自然对数</li>
<li>Math.PI  圆周率，一个圆的周长和直径之比，约等于 <code>3.14159</code></li>
<li>Math.min([x,[y[,…]]])  返回零到多个数值中最小值</li>
<li>Math.max([x,[y[,…]]])  返回零到多个数值中最大值</li>
</ul>
</li>
<li>学习<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring">substring</a>方法，返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。语法：<code>str.substring(indexStart[, indexEnd])</code></li>
<li>由于空字符串不处理，所以<code>str+=&#39;0000000&#39;</code>这里是加7个0；加8个的话可能会导致在原字符串长度就可以整除8的情况下加一个空字符串；</li>
<li>由于是按行输入和按长度分解的，所以不应该直接使用str.split()函数分解成数组。与题意不符</li>
</ul>
<h4 id="T4-进制转换（中等）"><a href="#T4-进制转换（中等）" class="headerlink" title="T4.进制转换（中等）"></a>T4.进制转换（中等）</h4><p>题目描述：写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。<br>输入：输入一个十六进制的数值字符串。注意：一个用例会同时有多组输入数据，请处理多组输入的问题。<br>输出：输出该数值的十进制字符串。不同组的测试用例用\n隔开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    print(<span class="string">&#x27;&#x27;</span>+<span class="built_in">parseInt</span>(line,<span class="number">16</span>))</span><br><span class="line">    <span class="comment">//等于console.log(&#x27;&#x27;+parseInt(line,16))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li><code>parseInt(string,radix)</code>函数  : 解析radix进制的string为十进制数；如果string的第一个非空格字符不是数字或者radix不在[2,36]这个范围的话返回NaN;如果string不是一个字符串，则将其转换为字符串(使用  <code>ToString </code>抽象操作)。字符串开头的空白符将会被忽略。radix，从2到36，可以不写，但可能出错。</li>
<li>NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。</li>
<li>这个print()是封装过的console.log()</li>
<li>console.log()默认是换行的，不用单独处理，如果想输出换行，可以用console.log( ‘\n’ );</li>
<li>用’’+把结果转换成字符串</li>
</ul>
<h4 id="T5-字符个数统计（中等）"><a href="#T5-字符个数统计（中等）" class="headerlink" title="T5.字符个数统计（中等）"></a>T5.字符个数统计（中等）</h4><p>题目描述：  编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0<del>127)，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次<br>例如，对于字符串abaca而言，有a、b、c三种不同的字符，因此输出3。<br>输入：输入一行没有空格的字符串。<br>输出：输出范围在(0</del>127)字符的个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> line = readline()</span><br><span class="line"><span class="keyword">let</span> arr=[]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;line.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.indexOf(line[i])==-<span class="number">1</span>&amp;&amp;line.charCodeAt(i)&lt;=<span class="number">127</span>&amp;&amp;line.charCodeAt(i)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        arr.push(line[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length)</span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li><code>**str.charCodeAt(index)**</code> 方法返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的 UTF-16 代码单元。参数index：一个大于等于 <code>0</code>，小于字符串长度的整数。如果不是一个数值，则默认为 <code>0</code>。返回值：指定 <code>index</code> 处字符的 UTF-16 代码单元值的一个数字；如果 <code>index</code> 超出范围，<code>charCodeAt()</code> 返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>。</li>
</ul>
<h4 id="T6-数字颠倒（简单）"><a href="#T6-数字颠倒（简单）" class="headerlink" title="T6.数字颠倒（简单）"></a>T6.数字颠倒（简单）</h4><p>题目描述：  输入一个整数，将这个整数以字符串的形式逆序输出。 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001<br>输入：输入一个int整数<br>输出：将这个整数以字符串的形式逆序输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br><span class="line"><span class="keyword">let</span> line = readline()</span><br><span class="line"><span class="built_in">console</span>.log(line.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2</span></span><br><span class="line"><span class="keyword">let</span> line = <span class="built_in">String</span>(readline())</span><br><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=line.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    str+=line[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>

<h4 id="T7-字符串反转（简单）"><a href="#T7-字符串反转（简单）" class="headerlink" title="T7.字符串反转（简单）"></a>T7.字符串反转（简单）</h4><p>题目描述：  接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不                    超过1000）<br>输入：输入一行，为一个只包含小写字母的字符串。<br>输出：输出该字符串反转后的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = readline();</span><br><span class="line"><span class="keyword">var</span> length = input.length;</span><br><span class="line"><span class="keyword">if</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &gt; <span class="number">1000</span>)&#123;                <span class="comment">//字符串长度不超过1000</span></span><br><span class="line">        length = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(<span class="regexp">/^[a-z]+$/</span>.test(input))&#123;       <span class="comment">//只包含小写字母</span></span><br><span class="line">          <span class="built_in">console</span>.log(input.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T8-句子逆序（数组类题）（较难）"><a href="#T8-句子逆序（数组类题）（较难）" class="headerlink" title="T8.句子逆序（数组类题）（较难）"></a>T8.句子逆序（数组类题）（较难）</h4><p>题目描述：  将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”<br> 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符<br>输入：输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。<br>输出：得到逆序的句子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line.split(<span class="string">&quot; &quot;</span>).reverse().join(<span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T9-字符串排序（中等）"><a href="#T9-字符串排序（中等）" class="headerlink" title="T9.字符串排序（中等）"></a>T9.字符串排序（中等）</h4><p>题目描述：  给定n个字符串，请对n个字符串按照字典序排列。<br>输入：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。<br>输出：数据输出n行，输出结果为按照字典序排列的字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num=<span class="built_in">Number</span>(readline())</span><br><span class="line"><span class="keyword">let</span> arr=[]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    arr.push(readline())</span><br><span class="line">&#125;</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li>Number()  把readline接收到的字符串转换成数字</li>
<li>arr.sort()用<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地算法</a>对数组的元素进行排序，并返回数组。默认排序顺序是在将元素<strong>转换为字符串</strong>，然后比较它们的UTF-16代码单元值序列时构建的。<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort([compareFunction])</a></li>
<li>参数compareFunction，可省，用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 <code>compareFunction</code>），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/05/20/18-30-37/</url>
    <content><![CDATA[<ol>
<li><p>tcp,udp区别</p>
</li>
<li><p>tcp三次握手</p>
</li>
<li><p>为什么不是两次握手</p>
</li>
<li><p>四次挥手</p>
</li>
<li><p>为什么等待2msl</p>
</li>
<li><p>syn flood攻击</p>
</li>
<li><p>http特点</p>
</li>
<li><p>常见的响应状态码</p>
</li>
<li><p>http报文</p>
</li>
<li><p>http相关版本</p>
</li>
<li><p>http的请求方法</p>
</li>
<li><p>get和post的区别</p>
</li>
<li><p>HTTPS和http区别</p>
</li>
<li><p>对称加密和非对称加密 区别</p>
</li>
<li><p>https验证过程</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_43914604/article/details/104557738">计算机网络的分层结构、协议、服务和接口</a></p>
</li>
<li><p>OSI参考模型及功能 </p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>牛客华为-字符串类题-js</title>
    <url>/2021/05/10/01-30-15/</url>
    <content><![CDATA[<p>概览（共9题-题目）：<br>1.坐标描述（较难）        2.识别有效的IP地址和掩码并进行分类统计（困难）        3.简单错误记录（困难）<br>4.密码验证合格程序（较难）        5.简单密码破解（中等）        6.删除字符串中出现次数最少的字符（较难）        7.字符串排序（中等）        8.字符串加解密（较难）        9.字符串合并处理（较难）</p>
<span id="more"></span>

<h2 id="字符串类型题-js"><a href="#字符串类型题-js" class="headerlink" title="字符串类型题  js"></a>字符串类型题  js</h2><h4 id="T1-坐标描述（较难）"><a href="#T1-坐标描述（较难）" class="headerlink" title="T1.坐标描述（较难）"></a>T1.坐标描述（较难）</h4><p>题目描述：开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。<br>输入：  一行字符串   —— 合法坐标为A(或者D或者W或者S) + 数字（两位以内） ，坐标之间以;分隔。 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 输出：输出一个整数，表示输入字符串最后一个单词的长度。<br>输出：最终坐标，以逗号分隔</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2：</span></span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li></li>
</ul>
<h4 id="T2-识别有效的IP地址和掩码并进行分类统计（困难）"><a href="#T2-识别有效的IP地址和掩码并进行分类统计（困难）" class="headerlink" title="T2.识别有效的IP地址和掩码并进行分类统计（困难）"></a>T2.识别有效的IP地址和掩码并进行分类统计（困难）</h4><p>题目描述：  请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。<br>  所有的IP地址划分为 A,B,C,D,E五类<br>  A类地址1.0.0.0<del>126.255.255.255;<br>  B类地址128.0.0.0</del>191.255.255.255;<br>  C类地址192.0.0.0<del>223.255.255.255;<br>  D类地址224.0.0.0</del>239.255.255.255；<br>  E类地址240.0.0.0~255.255.255.255 </p>
<p> 私网IP范围是：<br>  10.0.0.0～10.255.255.255<br>  172.16.0.0～172.31.255.255<br>  192.168.0.0～192.168.255.255<br>  子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）<br>  注意二进制下全是1或者全是0均为非法 </p>
<p>  注意：<br> \1. 类似于【0.<em>.</em>.<em>】和【127.</em>.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时可以忽略        \2. 私有IP地址和A,B,C,D,E类地址是不冲突的<br>输入：多行字符串。每行一个IP地址和掩码，用~隔开。<br>输出：统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li></li>
</ul>
<h4 id="T3-简单错误记录（困难）"><a href="#T3-简单错误记录（困难）" class="headerlink" title="T3.简单错误记录（困难）"></a>T3.简单错误记录（困难）</h4><p>题目描述：  开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。<br>  处理：<br>  1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是**错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是”相同“的错误记录。<br>  2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；<br>  3、 输入的文件可能带路径，记录文件名称不能带路径。<br>  4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准</p>
<p>输入：每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。<br>输出：将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2</span></span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li></li>
</ul>
<h4 id="T4-密码验证合格程序（较难）"><a href="#T4-密码验证合格程序（较难）" class="headerlink" title="T4.密码验证合格程序（较难）"></a>T4.密码验证合格程序（较难）</h4><p>题目描述：<br>    密码要求:   1.长度超过8位<br>                       2.包括大小写字母.数字.其它符号,以上四种至少三种<br>                       3.不能有相同长度大于2的子串重复<br>输入：一组或多组长度超过2的字符串。每组占一行<br>输出：如果符合要求输出：OK，否则输出NG</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li></li>
</ul>
<h4 id="T5-简单密码破解（中等）"><a href="#T5-简单密码破解（中等）" class="headerlink" title="T5.简单密码破解（中等）"></a>T5.简单密码破解（中等）</h4><p>题目描述：<br>    密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。<br>     假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。<br>     他是这么变换的，大家都知道手机上的字母： 1–1， abc–2, def–3, ghi–4, jkl–5, mno–6, pqrs–7, tuv–8 wxyz–9, 0–0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，<br>      声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。<br>输入：输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾<br>输出：输出渊子真正的密文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>收获：</p>
<ul>
<li></li>
</ul>
<h4 id="T6-删除字符串中出现次数最少的字符（较难）"><a href="#T6-删除字符串中出现次数最少的字符（较难）" class="headerlink" title="T6.删除字符串中出现次数最少的字符（较难）"></a>T6.删除字符串中出现次数最少的字符（较难）</h4><p>题目描述：    实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。   注意每个输入文件有多组输入，即多个字符串用回车隔开<br>输入：字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。<br>输出：删除字符串中出现次数最少的字符后的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="T7-字符串排序（中等）"><a href="#T7-字符串排序（中等）" class="headerlink" title="T7.字符串排序（中等）"></a>T7.字符串排序（中等）</h4><p>题目描述：    编写一个程序，将输入字符串中的字符按如下规则排序。</p>
<p> 规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。</p>
<p> 如，输入： Type 输出： epTy</p>
<p> 规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。</p>
<p> 如，输入： BabA 输出： aABb</p>
<p> 规则 3 ：非英文字母的其它字符保持原来的位置。</p>
<p> 如，输入： By?e 输出： Be?y<br>注意有多组测试数据，即输入有多行，每一行单独处理（换行符隔开的表示不同行）</p>
<p>输入：输入字符串<br>输出：输出字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="T8-字符串加解密（较难）"><a href="#T8-字符串加解密（较难）" class="headerlink" title="T8.字符串加解密（较难）"></a>T8.字符串加解密（较难）</h4><p>题目描述：    1、对输入的字符串进行加解密，并输出。 </p>
<p>  2、加密方法为： </p>
<p>  当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a； </p>
<p>  当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0； </p>
<p>  其他字符不做变化。 </p>
<p>  3、解密方法为加密的逆过程。 </p>
<p>本题含有多组样例输入。</p>
<p>输入：<br>输入一串要加密的密码<br>输入一串加过密的密码</p>
<p>输出：<br>输出加密后的字符<br>输出解密后的字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="T9-字符串合并处理（较难）"><a href="#T9-字符串合并处理（较难）" class="headerlink" title="T9.字符串合并处理（较难）"></a>T9.字符串合并处理（较难）</h4><p>题目描述：    按照指定规则对输入的字符串进行处理。 </p>
<p>  详细描述： </p>
<p>  将输入的两个字符串合并。 </p>
<p>  对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标意思是字符在字符串中的位置。 </p>
<p>   对排序后的字符串进行操作，如果字符为‘0’——‘9’或者‘A’——‘F’或者‘a’——‘f’，则对他们所代表的16进制的数进行BIT倒序的操作，并转换为相应的大写字符。如字符为‘4’，为0100b，则翻转后为0010b，也就是2。转换后的字符为‘2’； 如字符为‘7’，为0111b，则翻转后为1110b，也就是e。转换后的字符为大写‘E’。 </p>
<p>  举例：输入str1为”dec”，str2为”fab”，合并为“decfab”，分别对“dca”和“efb”进行排序，排序后为“abcedf”，转换后为“5D37BF” </p>
<p>  注意本题含有多组样例输入</p>
<p>输入：本题含有多组样例输入。每组样例输入两个字符串，用空格隔开。<br>输出：输出转化后的结果。每组样例输出一行。</p>
<p>收获：</p>
<p>- </p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/09/17/18-32-40/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>web Socket</title>
    <url>/2021/09/19/17-16-35/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>9.19-结构化拷贝</title>
    <url>/2021/09/19/17-16-00/</url>
    <content><![CDATA[<h1 id="结构化拷贝"><a href="#结构化拷贝" class="headerlink" title="结构化拷贝"></a>结构化拷贝</h1><p> 结构化拷贝 ：结构化克隆算法是<a href="https://www.w3.org/html/wg/drafts/html/master/infrastructure.html#safe-passing-of-structured-data">由HTML5规范定义</a>的用于复制复杂JavaScript对象的算法。通过来自 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">Workers</a>的 <code>postMessage() </code>或使用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/IndexedDB">IndexedDB</a> 存储对象时在内部使用。它通过递归输入对象来构建克隆，同时保持先前访问过的引用的映射，以避免无限遍历循环。</p>
<h6 id="结构化克隆算法"><a href="#结构化克隆算法" class="headerlink" title="结构化克隆算法"></a>结构化克隆算法</h6><p>结构化克隆算法是<a href="https://www.w3.org/html/wg/drafts/html/master/infrastructure.html#safe-passing-of-structured-data">由HTML5规范定义</a>的用于复制复杂JavaScript对象的算法。通过来自 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">Workers</a>的 <code>postMessage() </code>或使用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/IndexedDB">IndexedDB</a> 存储对象时在内部使用。它通过递归输入对象来构建克隆，同时保持先前访问过的引用的映射，以避免无限遍历循环。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#%E7%BB%93%E6%9E%84%E5%8C%96%E5%85%8B%E9%9A%86%E6%89%80%E4%B8%8D%E8%83%BD%E5%81%9A%E5%88%B0%E7%9A%84">结构化克隆所不能做到的</a></p>
<ul>
<li><strong><code>Error</code> 以及 <code>Function</code> 对象</strong>是不能被结构化克隆算法复制的；如果你尝试这样子去做，这会导致抛出 <code>DATA_CLONE_ERR</code> 的异常。</li>
<li>企图去克隆 <strong>DOM 节点</strong>同样会抛出 <code>DATA_CLONE_ERR</code> 异常。</li>
<li><strong>对象的某些特定参</strong>数也不会被保留  <ul>
<li><code>RegExp </code>对象的 <strong><code>lastIndex</code> 字段</strong>不会被保留</li>
<li>属性描述符，setters 以及 getters（以及其他类似元数据的功能）同样不会被复制。例如，如果一个对象用属性描述符标记为 read-only，它将会被复制为 read-write，因为这是默认的情况下。</li>
<li>原形链上的属性也不会被追踪以及复制。</li>
</ul>
</li>
</ul>
<h5 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#%E6%94%AF%E6%8C%81%E7%9A%84%E7%B1%BB%E5%9E%8B">支持的类型</a></h5><table>
<thead>
<tr>
<th>对象类型</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%8E%9F%E5%A7%8B%E5%80%BC">所有的原始类型</a></td>
<td>symbols 除外</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean">Boolean</a> 对象</td>
<td></td>
</tr>
<tr>
<td>String 对象</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a></td>
<td><code>lastIndex</code> 字段不会被保留。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList"><code>FileList</code></a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">ArrayBufferView</a></td>
<td>这基本上意味着所有的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">类型化数组</a> ，如 Int32Array 等。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData"><code>ImageData</code></a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a></td>
<td>仅包括普通对象（如对象字面量）</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a></td>
<td></td>
</tr>
</tbody></table>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5">相关链接</a></h2><ul>
<li><a href="https://www.w3.org/TR/html5/infrastructure.html#safe-passing-of-structured-data">HTML5 Specification: Safe passing of structured data</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/history"><code>window.history</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage"><code>window.postMessage()</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Components.utils.cloneInto">Components.utils.cloneInto</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>9.17 一个人也要像一支队伍</title>
    <url>/2021/09/15/16-22-08/</url>
    <content><![CDATA[<p>写日记的第一天 - 9.17 16:22</p>
<h3 id="看一篇面经，学习，回答问题，录一个视频。"><a href="#看一篇面经，学习，回答问题，录一个视频。" class="headerlink" title="看一篇面经，学习，回答问题，录一个视频。"></a>看一篇面经，学习，回答问题，录一个视频。</h3><p>作者：小土豆不会掉头发<br>链接：<a href="https://www.nowcoder.com/discuss/745089">https://www.nowcoder.com/discuss/745089</a><br>来源：牛客网</p>
<p>1.git工作流 </p>
<p>  2.git如果出现冲突怎么办 </p>
<p>  3.git同样的先后提交的东西，怎么覆盖 </p>
<p>  4.git撤回操作 </p>
<p>  答得特别不好，git工作流脑子里都不知该怎么组织语言，不是面试官想要的回答 </p>
<h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><h5 id="git主要优点"><a href="#git主要优点" class="headerlink" title="git主要优点"></a>git主要优点</h5><ul>
<li>分布式存储，本地仓库包含了远程仓库的所有内容</li>
<li>安全性高，远程仓库文件丢失了也不怕</li>
<li>优秀的分支模型，创建/合并分支都非常快捷便捷</li>
</ul>
<h5 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h5><p>我们在实际工作中会创建很多分支以便于不同场景下的开发，但是如果没有分支规范就会造成分支杂乱，大家往往也搞不清楚一个分支是做什么，下面我们就介绍一下我们常用的并且推荐大家使用的分支类型。</p>
<h6 id="git分支类型"><a href="#git分支类型" class="headerlink" title="git分支类型"></a>git分支类型</h6><p>[master分支]</p>
<p>-master 为产品主分支，该分支为只读唯一分支，也是用于部署生产环境的分支，需确保master分支的稳定性。<br>-master 分支一般由 release 分支或 hotfix 分支合并，任何情况下都不应该直接修改master分支代码<br>-产品的功能全部实现后，最终在master分支对外发布，另外所有在 master 分支的推送应该打标签（tag）做记录，方便追溯。<br>-master 分支不可删除</p>
<p>develop 分支<br>-develop 为主开发分支，基于 master 分支创建，始终保持最新完成功能的代码以及bug修复后的代码<br>-develop 分支为只读唯一分支，只能从其他分支合并，不可以直接在该分支合并做功能开发或bug修复<br>-一般开发新功能时，feature 分支都是基于develop 分支下创建的。<br>-develop 分支包含所有要发布到下一个 release 的代码<br>-feature 功能分支完成后，开发人员需合并到develop分支（不推送远程），需先将develop分支合并到release分支，进行提测。<br>-当所有新功能开发完成后，开发人员需合并到develop分支（不推送远程），需要将develop 分支合并到 feature,解决完冲突后再合并到develop分支。<br>-当所有新功能开发完成后，开发人员并自测完成后，此时从develop拉取release分支，进行提测<br>-release或hotfix分支上线完成后 ，开发人员需合并到develop分支并推送远程<br>-develop分支不可删</p>
<p>feature分支<br>-feature 分支通常为新功能或新特性开发分支，以develop分支为基础创建feature分支<br>-分支命名： feature /开头的为新特性或新功能分支，建议的命名规则： feature/use_createtime_feature,例如：feature/ftd_20201018_alipay, 含义为：开发人员ftd在20201018创建了一个支付宝支付的功能分支。<br>-新特性或新功能开发完成后，开发人员需合并到develop分支<br>-feature 分支可同时存在多个，用于团队中多个功能同时开发<br>-feature分支属于临时分支，功能完成后可选删除</p>
<p>release 分支<br>-release 分支为预上线分支，基于本次上线所有的feature分支合并到develop分支之后，从develop分支创建<br>-分支命名： release/开头的为预上线分支，建议的命名规则：release/version_publishtime,例如：release/v2.1.1_20201018。<br>-release 分支主要用于提交给测试人员进行功能测试。发布提测阶段，会以release 分支代码为基准进行提测。测试过程中发现的bug在本分支进行修复，上线完成后需合并到develop/master分支并推送远程<br>-release 分支属于临时分支，产品上线后可选删除</p>
<p>“当有一组feature开发完成后，首先开发人员会各自将最新功能代码合并到develop分支。进入提测阶段时，开发组长在develop 分支上创建 release 分支。如果在测试过程中发现bug需要修复，则直接由开发者在release分支修复并提交。当测试完成后，开发组长将release分支合并到master和develop分支，此时master为最新可发布代码，用作产品发布上线”</p>
<p>hotfix 分支<br>-hotfix 分支为线上bug 修复分支或补丁分支，主要用于对线上的版本进行bug修复<br>-分支命名：hotfix/ 开发的为修复分支，他的命名规则与feature分支类似，建议的命名规则：hotfix/user_createtime_hotfix，例如：hotfix/ftd_20201018_alipaybugfix，含义为：开发人员ftd在20201018创建了一个支付宝支付bug修复的分支<br>-hotfix 分支用于线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支。当问题修复完成后，需要合并到master分支和develop分支并推送远程。<br>-所有hotfix分支的修改会进入到下一个release。<br>-hotfix 分支属于临时分支，bug修复上线后可选删除。</p>
<h5 id="git日志规范"><a href="#git日志规范" class="headerlink" title="git日志规范"></a>git日志规范</h5><p>“在一个团队协作的项目中，开发人员需要经常提交一些代码去修复bug或者实现新的feature。而项目中的文件和实现什么功能、解决什么问题都会渐渐淡忘，最后需要浪费时间去阅读代码。但是好的日志规范commit message编写有帮助到我们，它也反映了一个开发人员是否是良好的协作者”</p>
<p>编写良好的Commit messages可以达到3个重要的目的：</p>
<ul>
<li>加快代码view的流程</li>
<li>帮助开发人员编写良好的版本发布日志</li>
<li>让之后的维护者了解代码里出现特定变化和feature被添加的原因</li>
</ul>
<p>「目前，社区有多种 Commit message 的写法规范。来自Angular 规范是目前使用最广的写法，比较合理和系统化。建议使用如下：」</p>
<p><strong>Commit messages的基本语法</strong></p>
<p>具体格式为:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># EN</span><br><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line"># CN</span><br><span class="line">&lt;类型&gt;[可选的作用域]: &lt;描述&gt;</span><br><span class="line">[可选的正文]</span><br><span class="line">[可选的脚注]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type: 本次 commit 的类型，诸如 bugfix、docs、style 等，类型说明参见下方。</p>
</li>
<li><p>scope: 本次 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
</li>
<li><p>subject: 简明扼要的阐述下本次 commit 的主旨，是 commit 目的的简短描述，建议不超过50个字符。</p>
</li>
<li><p>body: 在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，详细的修改方法或其他需要额外重点说明的内容。</p>
</li>
<li><p>footer: 描述下与之关联的 issue 或 break change，详见案例。</p>
<h5 id="Type的类别说明："><a href="#Type的类别说明：" class="headerlink" title="Type的类别说明："></a><strong>Type的类别说明：</strong></h5></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 主要type</span><br><span class="line">feat: 增加新功能</span><br><span class="line">fix: 修复bug</span><br><span class="line"> </span><br><span class="line"># 特殊type</span><br><span class="line">docs: 只改动了文档相关的内容</span><br><span class="line">style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号</span><br><span class="line">build: 构造工具的或者外部依赖的改动，例如webpack，npm</span><br><span class="line">refactor: 代码重构时使用</span><br><span class="line">revert: 执行git revert打印的message</span><br><span class="line"> </span><br><span class="line"># 暂不使用type</span><br><span class="line">test: 添加测试或者修改现有测试</span><br><span class="line">perf: 提高性能的改动</span><br><span class="line">ci: 与CI（持续集成服务）有关的改动</span><br><span class="line">chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure>

<h5 id="Commit-messages格式要求"><a href="#Commit-messages格式要求" class="headerlink" title="Commit messages格式要求"></a><strong>Commit messages格式要求</strong></h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 标题行：50个字符以内，描述主要变更内容</span><br><span class="line">#</span><br><span class="line"># 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:</span><br><span class="line">#</span><br><span class="line"># * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等</span><br><span class="line"># * 如何解决这个问题? 具体描述解决问题的步骤</span><br><span class="line"># * 是否存在副作用、风险? </span><br><span class="line">#</span><br><span class="line"># 如果需要的话可以添加一个链接到issue地址或者其它文档</span><br></pre></td></tr></table></figure>

<p> <strong>示例：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># fix：修复支付宝支付bug</span><br><span class="line">#</span><br><span class="line"># 1，修复支付完成后未查询支付状态问题</span><br><span class="line"># 2，增加定时任务保证支付状态完整</span><br><span class="line">#</span><br><span class="line"># link：http://github.com/ftd/shopmall/issue001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝ 注：如果一次改动内容较多，包含多个提交类型时，建议拆分成多个提交，分次提交，这样会更清晰。<br> ❞</p>
</blockquote>
<h5 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git Flow工作流"></a><strong>Git Flow工作流</strong></h5><p>我们现在已经了解了Git的分支，包括分支有哪些类型，什么情况下使用什么类型的分支，以及提交的格式规范等。不过往往在一个团队人数较多，创建的分支也比较多的时候，还是会带来很多分支操作上的困扰。那有没有一个什么好的流程来规范大家呢，针对这些问题，建议大家使用Git Flow的工作流模式。</p>
<h5 id="Git-Flow-流程图"><a href="#Git-Flow-流程图" class="headerlink" title="Git Flow 流程图"></a><strong>Git Flow 流程图</strong></h5><h6 id="「1，主分支流程」"><a href="#「1，主分支流程」" class="headerlink" title="「1，主分支流程」"></a><strong>「1，主分支流程」</strong></h6><ul>
<li>master分支记录了每次版本发布历史和tag标记。</li>
<li>develop分支记录了所有开发的版本历史。</li>
<li>develop分支仅第一次创建时从master分支拉取。 </li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-7d04bd950aa8e174f5bc0927d0dddf65_r.jpg"></p>
<h6 id="「2，开发流程」"><a href="#「2，开发流程」" class="headerlink" title="「2，开发流程」"></a><strong>「2，开发流程」</strong></h6><ul>
<li>feature分支是从develop分支拉取的分支。</li>
<li>每个feature完成后需合并到develop分支。 </li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-4370d55e601c789c028041406034c635_720w.jpg"></p>
<h6 id="「3，提测发布流程」"><a href="#「3，提测发布流程」" class="headerlink" title="「3，提测发布流程」"></a><strong>「3，提测发布流程」</strong></h6><ul>
<li>release分支是在所有功能开发自测完成后，从develop分支拉取的分支。</li>
<li>release分支一旦创建后，通常不再从develop分支拉取，该分支只做bug修复，文档生成和其他面向发布的任务。</li>
<li>release分支测试完成，达到上线标准后，需合并回master分支和develop分支。 </li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-34e42ecbcb3ed91086926bdf3857e4ad_720w.jpg"></p>
<h6 id="「4，bug修复流程」"><a href="#「4，bug修复流程」" class="headerlink" title="「4，bug修复流程」"></a><strong>「4，bug修复流程」</strong></h6><ul>
<li>hotfix分支是在线上出现bug之后，从master分支拉取的分支。</li>
<li>hotfix分支测试完成后，需合并回master分支和develop分支。 </li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-70e259e69263b64222ee332a8678e498_720w.jpg"></p>
<h5 id="Git-Flow实战"><a href="#Git-Flow实战" class="headerlink" title="Git Flow实战"></a><strong>Git Flow实战</strong></h5><p>Git Flow的流程搞清楚后，我们下面开始实际的项目实战，假设我们现在有一个商城的项目，并且我们已经建好了Git仓库。</p>
<p>我们通过命令行和图形界面的方式分别向大家展示如何使用Git Flow工作流。</p>
<h5 id="Git-Flow-命令示例"><a href="#Git-Flow-命令示例" class="headerlink" title="Git Flow 命令示例"></a><strong>Git Flow 命令示例</strong></h5><h5 id="开始-Feature"><a href="#开始-Feature" class="headerlink" title="开始 Feature"></a><strong>开始 Feature</strong></h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 创建feature分支</span><br><span class="line">git flow feature start ftd_20201018_wechatpay</span><br><span class="line"></span><br><span class="line"># 指定当前分支pull的源为develop</span><br><span class="line">git branch --set-upstream-to=origin/develop feature/ftd_20201018_wechatpay</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 发布feature</span><br><span class="line">git flow feature publish ftd_20201018_wechatpay</span><br><span class="line"></span><br><span class="line"># 完成feature</span><br><span class="line">git flow feature finish ftd_20201018_wechatpay</span><br><span class="line"></span><br><span class="line">开始 Release</span><br><span class="line">git flow release start v1.0_20201031</span><br><span class="line"></span><br><span class="line">完成 Release</span><br><span class="line">git flow release finish v1.0_20201031</span><br><span class="line"></span><br><span class="line">开始 Hotfix</span><br><span class="line">git flow hotfix start ftd_20201031_bugfix</span><br><span class="line"></span><br><span class="line">完成 Hotfix</span><br><span class="line">git flow hotfix finish ftd_20201031_bugfix</span><br></pre></td></tr></table></figure>

<p>大家可以看到，简简单单几行命令就可以完成比较复杂的流程管理，如果对于命令行不太擅长的小伙伴还可以使用图形工具，这里推荐使用sourcetree，sourcetree也是著名的Git管理工具，可以大大方便我们对Git的操作和使用，下面就来介绍一下sourcetree中如何使用Git Flow。（以下内容为Windows版本的sourcetree为例，Mac类似）</p>
<h3 id="初始化GitFlow"><a href="#初始化GitFlow" class="headerlink" title="初始化GitFlow"></a><strong>初始化GitFlow</strong></h3><p>打开sourcetree，选择想使用Git Flow工作流的项目，在右上角点击Git工作流按钮，如下图所示： </p>
<p><img src="https://pic3.zhimg.com/80/v2-8905db964ffa612296317a9572348dca_720w.jpg"></p>
<p>随后会弹出对话框，可以选择产品分支，开发分支以及功能分支等，如下图所示： </p>
<p>点击确定后完成仓库的Git Flow初始化。</p>
<h5 id="开始-Feature-1"><a href="#开始-Feature-1" class="headerlink" title="开始 Feature"></a><strong>开始 Feature</strong></h5><p>点击右上角Git工作流，显示如图界面： </p>
<p><img src="https://pic2.zhimg.com/80/v2-b6bf6c5cf942bddd9946868f0e7ec79d_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7daf41b5234c9efd19aef1addbc8d31d_720w.jpg"></p>
<p>输入本次功能的名称，点击确定创建feature分支 </p>
<p><img src="https://pic3.zhimg.com/80/v2-830ba50a587884e2ef94a9c954f37226_720w.jpg"></p>
<p>可以看到本地已经有了新建的feature分支，如图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-432bf105f9c80df5c841ad423b9e1c6f_720w.jpg"></p>
<p>然后就可以在该分支进行功能开发了。</p>
<h5 id="完成-Feature"><a href="#完成-Feature" class="headerlink" title="完成 Feature"></a><strong>完成 Feature</strong></h5><p>功能开发完成之后，还是点击右上角Git工作流，显示如图界面： </p>
<p><img src="https://pic4.zhimg.com/80/v2-13ca7c5c6d1fe3619657f0e924ac6697_720w.jpg"></p>
<p>点击完成功能，如下图所示： </p>
<p><img src="https://pic4.zhimg.com/80/v2-2fa75372ae37b06f2da85fdcd2f929cf_720w.jpg"></p>
<p>这里可以选择将该feature分支删除或保留，可以根据团队的规定来处理即可。</p>
<p>点击确定后，完成feature功能的开发。</p>
<p>至此该流程处理完毕。</p>
<h5 id="开始-Release"><a href="#开始-Release" class="headerlink" title="开始 Release"></a><strong>开始 Release</strong></h5><p>同样的，点击右上角Git工作流，选择建立新的发布版本，显示如下： </p>
<p><img src="https://pic2.zhimg.com/80/v2-ed17790cb44fcac6caca7df237f4c955_720w.jpg"></p>
<p>输入发布版本名称，点击确定，完成release分支的创建。</p>
<p>此时可以看到已经创建的release分支，如下图所示： </p>
<p><img src="https://pic4.zhimg.com/80/v2-68c8331fe778adae2968f797787a43e7_720w.jpg"></p>
<h5 id="完成-Release"><a href="#完成-Release" class="headerlink" title="完成 Release"></a><strong>完成 Release</strong></h5><p>测试通过后，可以进行release版本的发布，如下图所示： </p>
<p><img src="https://pic1.zhimg.com/80/v2-27e3134ee9c2a53b5b82c800793cdfc4_720w.jpg"></p>
<p>输入该发布的标签信息，点击确定进行发布。</p>
<p>至此，我们已经完成了release的发布流程。</p>
<h5 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a><strong>Hotfix</strong></h5><p>hotfix流程与上述流程操作方法类似，再次不再赘述，大家可以通过软件进行操作练习。</p>
<h3 id="常用-Git-命令清单"><a href="#常用-Git-命令清单" class="headerlink" title="常用 Git 命令清单"></a>常用 Git 命令清单</h3><p>作者： <a href="https://www.ruanyifeng.com/">阮一峰</a></p>
<p>我每天使用 Git ，但是很多命令记不住。</p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png"></p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h5 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h5><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h5><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h5 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h5><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<h5 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h5><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h5 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h5 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h5 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>







<p>5.给了一个网页图片排列，如何实现下面：（不要想着用css以及js） </p>
<ul>
<li> 1.搜索，顺序不能变 </li>
<li> \2. 已知原始宽高 </li>
<li> \3. 只能等比形变，不能裁减 </li>
<li> 说了3种方法，实现是没听懂他的意思，面试官后来说关键的点在每一行图片的高度不一样，得自己一排排就设定 </li>
<li> 崩溃了我 </li>
</ul>
<p>​    6.写一个深拷贝   </p>
<p>​    7.深拷贝的方法用json有什么缺点   </p>
<p>​    7.jit即时编译   </p>
<p>​    8.基本数据存在哪里，有什么特点   </p>
<p>​    9.怎么把字符串变成数组   </p>
<p>​    9.为什么基本数据类型有方法   </p>
<p>​    10.跨页面通信的方法以及api   </p>
<p>​    11.跨页面通信中我说了localstorage，哪些场景不能用？   </p>
<p>​    12.同源策略中的websocket了解嘛   </p>
<p>​    13.vue中data没有初始化，为什么不能直接赋值？   </p>
<h3 id="JavaScript-split-方法"><a href="#JavaScript-split-方法" class="headerlink" title="JavaScript split() 方法"></a>JavaScript split() 方法</h3><h4 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h4><p>split() 方法用于把一个字符串分割成字符串数组。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>stringObject.split(separator,howmany)</p>
<ul>
<li>separator: 必需。字符串或者正则表达式，从该参数指定的地方分割stringObject。</li>
<li>howmany: 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个字符串数组。该数组是通过在separator指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。</p>
<p>但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）</p>
<h4 id="提示和注释"><a href="#提示和注释" class="headerlink" title="提示和注释"></a>提示和注释</h4><p>注释：如果把空字符串（””）用作 separator，那么 stringObject 中的每个字符之间都会被分割</p>
<p>注释：String.split() 执行的操作与 Array.join 执行的操作是相反的</p>
<h3 id="JavaScript-slice-方法"><a href="#JavaScript-slice-方法" class="headerlink" title="JavaScript slice() 方法"></a>JavaScript slice() 方法</h3><h5 id="定义和用法-1"><a href="#定义和用法-1" class="headerlink" title="定义和用法"></a>定义和用法</h5><p>slice() 方法可从已有的数组中返回选定的元素</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>arrayObject.slice(start,end)</p>
<p>start: 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。</p>
<p>end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从start到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()</p>
]]></content>
  </entry>
  <entry>
    <title>git</title>
    <url>/2021/09/18/15-05-34/</url>
    <content><![CDATA[<h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><h5 id="git主要优点"><a href="#git主要优点" class="headerlink" title="git主要优点"></a>git主要优点</h5><ul>
<li>分布式存储，本地仓库包含了远程仓库的所有内容</li>
<li>安全性高，远程仓库文件丢失了也不怕</li>
<li>优秀的分支模型，创建/合并分支都非常快捷便捷</li>
</ul>
<h5 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h5><p>我们在实际工作中会创建很多分支以便于不同场景下的开发，但是如果没有分支规范就会造成分支杂乱，大家往往也搞不清楚一个分支是做什么，下面我们就介绍一下我们常用的并且推荐大家使用的分支类型。</p>
<h6 id="git分支类型"><a href="#git分支类型" class="headerlink" title="git分支类型"></a>git分支类型</h6><p>[master分支]</p>
<p>-master 为产品主分支，该分支为只读唯一分支，也是用于部署生产环境的分支，需确保master分支的稳定性。<br>-master 分支一般由 release 分支或 hotfix 分支合并，任何情况下都不应该直接修改master分支代码<br>-产品的功能全部实现后，最终在master分支对外发布，另外所有在 master 分支的推送应该打标签（tag）做记录，方便追溯。<br>-master 分支不可删除</p>
<p>develop 分支<br>-develop 为主开发分支，基于 master 分支创建，始终保持最新完成功能的代码以及bug修复后的代码<br>-develop 分支为只读唯一分支，只能从其他分支合并，不可以直接在该分支合并做功能开发或bug修复<br>-一般开发新功能时，feature 分支都是基于develop 分支下创建的。<br>-develop 分支包含所有要发布到下一个 release 的代码<br>-feature 功能分支完成后，开发人员需合并到develop分支（不推送远程），需先将develop分支合并到release分支，进行提测。<br>-当所有新功能开发完成后，开发人员需合并到develop分支（不推送远程），需要将develop 分支合并到 feature,解决完冲突后再合并到develop分支。<br>-当所有新功能开发完成后，开发人员并自测完成后，此时从develop拉取release分支，进行提测<br>-release或hotfix分支上线完成后 ，开发人员需合并到develop分支并推送远程<br>-develop分支不可删</p>
<p>feature分支<br>-feature 分支通常为新功能或新特性开发分支，以develop分支为基础创建feature分支<br>-分支命名： feature /开头的为新特性或新功能分支，建议的命名规则： feature/use_createtime_feature,例如：feature/ftd_20201018_alipay, 含义为：开发人员ftd在20201018创建了一个支付宝支付的功能分支。<br>-新特性或新功能开发完成后，开发人员需合并到develop分支<br>-feature 分支可同时存在多个，用于团队中多个功能同时开发<br>-feature分支属于临时分支，功能完成后可选删除</p>
<p>release 分支<br>-release 分支为预上线分支，基于本次上线所有的feature分支合并到develop分支之后，从develop分支创建<br>-分支命名： release/开头的为预上线分支，建议的命名规则：release/version_publishtime,例如：release/v2.1.1_20201018。<br>-release 分支主要用于提交给测试人员进行功能测试。发布提测阶段，会以release 分支代码为基准进行提测。测试过程中发现的bug在本分支进行修复，上线完成后需合并到develop/master分支并推送远程<br>-release 分支属于临时分支，产品上线后可选删除</p>
<p>“当有一组feature开发完成后，首先开发人员会各自将最新功能代码合并到develop分支。进入提测阶段时，开发组长在develop 分支上创建 release 分支。如果在测试过程中发现bug需要修复，则直接由开发者在release分支修复并提交。当测试完成后，开发组长将release分支合并到master和develop分支，此时master为最新可发布代码，用作产品发布上线”</p>
<p>hotfix 分支<br>-hotfix 分支为线上bug 修复分支或补丁分支，主要用于对线上的版本进行bug修复<br>-分支命名：hotfix/ 开发的为修复分支，他的命名规则与feature分支类似，建议的命名规则：hotfix/user_createtime_hotfix，例如：hotfix/ftd_20201018_alipaybugfix，含义为：开发人员ftd在20201018创建了一个支付宝支付bug修复的分支<br>-hotfix 分支用于线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支。当问题修复完成后，需要合并到master分支和develop分支并推送远程。<br>-所有hotfix分支的修改会进入到下一个release。<br>-hotfix 分支属于临时分支，bug修复上线后可选删除。</p>
<h5 id="git日志规范"><a href="#git日志规范" class="headerlink" title="git日志规范"></a>git日志规范</h5><p>“在一个团队协作的项目中，开发人员需要经常提交一些代码去修复bug或者实现新的feature。而项目中的文件和实现什么功能、解决什么问题都会渐渐淡忘，最后需要浪费时间去阅读代码。但是好的日志规范commit message编写有帮助到我们，它也反映了一个开发人员是否是良好的协作者”</p>
<p>编写良好的Commit messages可以达到3个重要的目的：</p>
<ul>
<li>加快代码view的流程</li>
<li>帮助开发人员编写良好的版本发布日志</li>
<li>让之后的维护者了解代码里出现特定变化和feature被添加的原因</li>
</ul>
<p>「目前，社区有多种 Commit message 的写法规范。来自Angular 规范是目前使用最广的写法，比较合理和系统化。建议使用如下：」</p>
<p><strong>Commit messages的基本语法</strong></p>
<p>具体格式为:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># EN</span><br><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line"># CN</span><br><span class="line">&lt;类型&gt;[可选的作用域]: &lt;描述&gt;</span><br><span class="line">[可选的正文]</span><br><span class="line">[可选的脚注]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type: 本次 commit 的类型，诸如 bugfix、docs、style 等，类型说明参见下方。</p>
</li>
<li><p>scope: 本次 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
</li>
<li><p>subject: 简明扼要的阐述下本次 commit 的主旨，是 commit 目的的简短描述，建议不超过50个字符。</p>
</li>
<li><p>body: 在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，详细的修改方法或其他需要额外重点说明的内容。</p>
</li>
<li><p>footer: 描述下与之关联的 issue 或 break change，详见案例。</p>
<h5 id="Type的类别说明："><a href="#Type的类别说明：" class="headerlink" title="Type的类别说明："></a><strong>Type的类别说明：</strong></h5></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 主要type</span><br><span class="line">feat: 增加新功能</span><br><span class="line">fix: 修复bug</span><br><span class="line"> </span><br><span class="line"># 特殊type</span><br><span class="line">docs: 只改动了文档相关的内容</span><br><span class="line">style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号</span><br><span class="line">build: 构造工具的或者外部依赖的改动，例如webpack，npm</span><br><span class="line">refactor: 代码重构时使用</span><br><span class="line">revert: 执行git revert打印的message</span><br><span class="line"> </span><br><span class="line"># 暂不使用type</span><br><span class="line">test: 添加测试或者修改现有测试</span><br><span class="line">perf: 提高性能的改动</span><br><span class="line">ci: 与CI（持续集成服务）有关的改动</span><br><span class="line">chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure>

<h5 id="Commit-messages格式要求"><a href="#Commit-messages格式要求" class="headerlink" title="Commit messages格式要求"></a><strong>Commit messages格式要求</strong></h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 标题行：50个字符以内，描述主要变更内容</span><br><span class="line">#</span><br><span class="line"># 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:</span><br><span class="line">#</span><br><span class="line"># * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等</span><br><span class="line"># * 如何解决这个问题? 具体描述解决问题的步骤</span><br><span class="line"># * 是否存在副作用、风险? </span><br><span class="line">#</span><br><span class="line"># 如果需要的话可以添加一个链接到issue地址或者其它文档</span><br></pre></td></tr></table></figure>

<p> <strong>示例：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># fix：修复支付宝支付bug</span><br><span class="line">#</span><br><span class="line"># 1，修复支付完成后未查询支付状态问题</span><br><span class="line"># 2，增加定时任务保证支付状态完整</span><br><span class="line">#</span><br><span class="line"># link：http://github.com/ftd/shopmall/issue001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝ 注：如果一次改动内容较多，包含多个提交类型时，建议拆分成多个提交，分次提交，这样会更清晰。<br>❞</p>
</blockquote>
<h5 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git Flow工作流"></a><strong>Git Flow工作流</strong></h5><p>我们现在已经了解了Git的分支，包括分支有哪些类型，什么情况下使用什么类型的分支，以及提交的格式规范等。不过往往在一个团队人数较多，创建的分支也比较多的时候，还是会带来很多分支操作上的困扰。那有没有一个什么好的流程来规范大家呢，针对这些问题，建议大家使用Git Flow的工作流模式。</p>
<h5 id="Git-Flow-流程图"><a href="#Git-Flow-流程图" class="headerlink" title="Git Flow 流程图"></a><strong>Git Flow 流程图</strong></h5><h6 id="「1，主分支流程」"><a href="#「1，主分支流程」" class="headerlink" title="「1，主分支流程」"></a><strong>「1，主分支流程」</strong></h6><ul>
<li>master分支记录了每次版本发布历史和tag标记。</li>
<li>develop分支记录了所有开发的版本历史。</li>
<li>develop分支仅第一次创建时从master分支拉取。 </li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-7d04bd950aa8e174f5bc0927d0dddf65_r.jpg"></p>
<h6 id="「2，开发流程」"><a href="#「2，开发流程」" class="headerlink" title="「2，开发流程」"></a><strong>「2，开发流程」</strong></h6><ul>
<li>feature分支是从develop分支拉取的分支。</li>
<li>每个feature完成后需合并到develop分支。 </li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-4370d55e601c789c028041406034c635_720w.jpg"></p>
<h6 id="「3，提测发布流程」"><a href="#「3，提测发布流程」" class="headerlink" title="「3，提测发布流程」"></a><strong>「3，提测发布流程」</strong></h6><ul>
<li>release分支是在所有功能开发自测完成后，从develop分支拉取的分支。</li>
<li>release分支一旦创建后，通常不再从develop分支拉取，该分支只做bug修复，文档生成和其他面向发布的任务。</li>
<li>release分支测试完成，达到上线标准后，需合并回master分支和develop分支。 </li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-34e42ecbcb3ed91086926bdf3857e4ad_720w.jpg"></p>
<h6 id="「4，bug修复流程」"><a href="#「4，bug修复流程」" class="headerlink" title="「4，bug修复流程」"></a><strong>「4，bug修复流程」</strong></h6><ul>
<li>hotfix分支是在线上出现bug之后，从master分支拉取的分支。</li>
<li>hotfix分支测试完成后，需合并回master分支和develop分支。 </li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-70e259e69263b64222ee332a8678e498_720w.jpg"></p>
<h5 id="Git-Flow实战"><a href="#Git-Flow实战" class="headerlink" title="Git Flow实战"></a><strong>Git Flow实战</strong></h5><p>Git Flow的流程搞清楚后，我们下面开始实际的项目实战，假设我们现在有一个商城的项目，并且我们已经建好了Git仓库。</p>
<p>我们通过命令行和图形界面的方式分别向大家展示如何使用Git Flow工作流。</p>
<h5 id="Git-Flow-命令示例"><a href="#Git-Flow-命令示例" class="headerlink" title="Git Flow 命令示例"></a><strong>Git Flow 命令示例</strong></h5><h5 id="开始-Feature"><a href="#开始-Feature" class="headerlink" title="开始 Feature"></a><strong>开始 Feature</strong></h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 创建feature分支</span><br><span class="line">git flow feature start ftd_20201018_wechatpay</span><br><span class="line"></span><br><span class="line"># 指定当前分支pull的源为develop</span><br><span class="line">git branch --set-upstream-to=origin/develop feature/ftd_20201018_wechatpay</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 发布feature</span><br><span class="line">git flow feature publish ftd_20201018_wechatpay</span><br><span class="line"></span><br><span class="line"># 完成feature</span><br><span class="line">git flow feature finish ftd_20201018_wechatpay</span><br><span class="line"></span><br><span class="line">开始 Release</span><br><span class="line">git flow release start v1.0_20201031</span><br><span class="line"></span><br><span class="line">完成 Release</span><br><span class="line">git flow release finish v1.0_20201031</span><br><span class="line"></span><br><span class="line">开始 Hotfix</span><br><span class="line">git flow hotfix start ftd_20201031_bugfix</span><br><span class="line"></span><br><span class="line">完成 Hotfix</span><br><span class="line">git flow hotfix finish ftd_20201031_bugfix</span><br></pre></td></tr></table></figure>

<p>大家可以看到，简简单单几行命令就可以完成比较复杂的流程管理，如果对于命令行不太擅长的小伙伴还可以使用图形工具，这里推荐使用sourcetree，sourcetree也是著名的Git管理工具，可以大大方便我们对Git的操作和使用，下面就来介绍一下sourcetree中如何使用Git Flow。（以下内容为Windows版本的sourcetree为例，Mac类似）</p>
<h3 id="初始化GitFlow"><a href="#初始化GitFlow" class="headerlink" title="初始化GitFlow"></a><strong>初始化GitFlow</strong></h3><p>打开sourcetree，选择想使用Git Flow工作流的项目，在右上角点击Git工作流按钮，如下图所示： </p>
<p><img src="https://pic3.zhimg.com/80/v2-8905db964ffa612296317a9572348dca_720w.jpg"></p>
<p>随后会弹出对话框，可以选择产品分支，开发分支以及功能分支等，如下图所示： </p>
<p>点击确定后完成仓库的Git Flow初始化。</p>
<h5 id="开始-Feature-1"><a href="#开始-Feature-1" class="headerlink" title="开始 Feature"></a><strong>开始 Feature</strong></h5><p>点击右上角Git工作流，显示如图界面： </p>
<p><img src="https://pic2.zhimg.com/80/v2-b6bf6c5cf942bddd9946868f0e7ec79d_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7daf41b5234c9efd19aef1addbc8d31d_720w.jpg"></p>
<p>输入本次功能的名称，点击确定创建feature分支 </p>
<p><img src="https://pic3.zhimg.com/80/v2-830ba50a587884e2ef94a9c954f37226_720w.jpg"></p>
<p>可以看到本地已经有了新建的feature分支，如图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-432bf105f9c80df5c841ad423b9e1c6f_720w.jpg"></p>
<p>然后就可以在该分支进行功能开发了。</p>
<h5 id="完成-Feature"><a href="#完成-Feature" class="headerlink" title="完成 Feature"></a><strong>完成 Feature</strong></h5><p>功能开发完成之后，还是点击右上角Git工作流，显示如图界面： </p>
<p><img src="https://pic4.zhimg.com/80/v2-13ca7c5c6d1fe3619657f0e924ac6697_720w.jpg"></p>
<p>点击完成功能，如下图所示： </p>
<p><img src="https://pic4.zhimg.com/80/v2-2fa75372ae37b06f2da85fdcd2f929cf_720w.jpg"></p>
<p>这里可以选择将该feature分支删除或保留，可以根据团队的规定来处理即可。</p>
<p>点击确定后，完成feature功能的开发。</p>
<p>至此该流程处理完毕。</p>
<h5 id="开始-Release"><a href="#开始-Release" class="headerlink" title="开始 Release"></a><strong>开始 Release</strong></h5><p>同样的，点击右上角Git工作流，选择建立新的发布版本，显示如下： </p>
<p><img src="https://pic2.zhimg.com/80/v2-ed17790cb44fcac6caca7df237f4c955_720w.jpg"></p>
<p>输入发布版本名称，点击确定，完成release分支的创建。</p>
<p>此时可以看到已经创建的release分支，如下图所示： </p>
<p><img src="https://pic4.zhimg.com/80/v2-68c8331fe778adae2968f797787a43e7_720w.jpg"></p>
<h5 id="完成-Release"><a href="#完成-Release" class="headerlink" title="完成 Release"></a><strong>完成 Release</strong></h5><p>测试通过后，可以进行release版本的发布，如下图所示： </p>
<p><img src="https://pic1.zhimg.com/80/v2-27e3134ee9c2a53b5b82c800793cdfc4_720w.jpg"></p>
<p>输入该发布的标签信息，点击确定进行发布。</p>
<p>至此，我们已经完成了release的发布流程。</p>
<h5 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a><strong>Hotfix</strong></h5><p>hotfix流程与上述流程操作方法类似，再次不再赘述，大家可以通过软件进行操作练习。</p>
<h3 id="Git-使用规范流程"><a href="#Git-使用规范流程" class="headerlink" title="Git 使用规范流程"></a>Git 使用规范流程</h3><p>作者： <a href="https://www.ruanyifeng.com/">阮一峰</a></p>
<p>日期： <a href="https://www.ruanyifeng.com/blog/2015/08/">2015年8月 5日</a></p>
<p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。</p>
<p>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。</p>
<p>下面是<a href="https://github.com/thoughtbot/guides/tree/master/protocol/git">ThoughtBot</a> 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015080501.png"></p>
<h5 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h5><p>首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考<a href="https://www.ruanyifeng.com/blog/2012/07/git.html">《Git分支管理策略》</a>）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取主干最新代码</span></span><br><span class="line">$ git checkout master</span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个开发分支myfeature</span></span><br><span class="line">$ git checkout -b myfeature</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h5><p>分支修改后，就可以提交commit了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add --all</span><br><span class="line">$ git status</span><br><span class="line">$ git commit --verbose</span><br></pre></td></tr></table></figure>
</blockquote>
<p>git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。</p>
<p>git status 命令，用来查看发生变动的文件。</p>
<p>git commit 命令的verbose参数，会列出 <a href="https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff</a> 的结果。</p>
<h5 id="第三步：撰写提交信息"><a href="#第三步：撰写提交信息" class="headerlink" title="第三步：撰写提交信息"></a>第三步：撰写提交信息</h5><p>提交commit时，必须给出完整扼要的提交信息，下面是一个范本。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Present-tense summary under 50 characters</span><br><span class="line"></span><br><span class="line">* More information about commit (under 72 characters).</span><br><span class="line">* More information about commit (under 72 characters).</span><br><span class="line"></span><br><span class="line">http://project.management-system.com/ticket/123</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。</p>
<h5 id="第四步：与主干同步"><a href="#第四步：与主干同步" class="headerlink" title="第四步：与主干同步"></a>第四步：与主干同步</h5><p>分支的开发过程中，要经常与主干保持同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure>

<h5 id="第五步：合并commit"><a href="#第五步：合并commit" class="headerlink" title="第五步：合并commit"></a>第五步：合并commit</h5><p>分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。</p>
<p>那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>git rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。</p>
<p>下面采用<a href="https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history">Tute Costa</a>的例子，来解释怎么合并commit。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick 07c5abd Introduce OpenPGP and teach basic usage</span><br><span class="line">pick de9b1eb Fix PostChecker::Post<span class="comment">#urls</span></span><br><span class="line">pick 3e7ee36 Hey kids, stop all the highlighting</span><br><span class="line">pick fa20af3 git interactive rebase, squash, amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 8db7e8b..fa20af3 onto 8db7e8b</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment">#  s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment">#  f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span></span><br><span class="line"><span class="comment">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>

<p>上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行rebase操作。</p>
<p>4个commit的下面是一大堆注释，列出可以使用的命令。</p>
<blockquote>
<ul>
<li>pick：正常选中</li>
<li>reword：选中，并且修改提交信息；</li>
<li>edit：选中，rebase时会暂停，允许你修改这个commit（参考<a href="https://schacon.github.io/gitbook/4_interactive_rebasing.html">这里</a>）</li>
<li>squash：选中，会将当前commit与上一个commit合并</li>
<li>fixup：与squash相同，但不会保存当前commit的提交信息</li>
<li>exec：执行其他shell命令</li>
</ul>
</blockquote>
<p>上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick 07c5abd Introduce OpenPGP and teach basic usage</span><br><span class="line">s de9b1eb Fix PostChecker::Post<span class="comment">#urls</span></span><br><span class="line">s 3e7ee36 Hey kids, stop all the highlighting</span><br><span class="line">pick fa20af3 git interactive rebase, squash, amend</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is a combination of 3 commits.</span></span><br><span class="line"><span class="comment"># The first commit&#x27;s message is:</span></span><br><span class="line">Introduce OpenPGP and teach basic usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the 2nd commit message:</span></span><br><span class="line">Fix PostChecker::Post<span class="comment">#urls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the 3rd commit message:</span></span><br><span class="line">Hey kids, stop all the highlighting</span><br></pre></td></tr></table></figure>

<p>如果将第三行的squash命令改成fixup命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick 07c5abd Introduce OpenPGP and teach basic usage</span><br><span class="line">s de9b1eb Fix PostChecker::Post<span class="comment">#urls</span></span><br><span class="line">f 3e7ee36 Hey kids, stop all the highlighting</span><br><span class="line">pick fa20af3 git interactive rebase, squash, amend</span><br></pre></td></tr></table></figure>
</blockquote>
<p>运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is a combination of 3 commits.</span></span><br><span class="line"><span class="comment"># The first commit&#x27;s message is:</span></span><br><span class="line">Introduce OpenPGP and teach basic usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the 2nd commit message:</span></span><br><span class="line">Fix PostChecker::Post<span class="comment">#urls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the 3rd commit message:</span></span><br><span class="line"><span class="comment"># Hey kids, stop all the highlighting</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://ponyfoo.com/articles/git-github-hacks">Pony Foo</a>提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD~5</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am <span class="string">&quot;Here&#x27;s the bug fix that closes #28&quot;</span></span><br><span class="line">$ git push --force</span><br></pre></td></tr></table></figure>
</blockquote>
<p>squash和fixup命令，还可以当作命令行参数使用，自动合并commit。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --fixup  </span><br><span class="line">$ git rebase -i --autosquash </span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个用法请参考<a href="https://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html">这篇文章</a>，这里就不解释了。</p>
<h5 id="第六步：推送到远程仓库"><a href="#第六步：推送到远程仓库" class="headerlink" title="第六步：推送到远程仓库"></a>第六步：推送到远程仓库</h5><p>合并commit后，就可以推送当前分支到远程仓库了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --force origin myfeature</span><br></pre></td></tr></table></figure>
</blockquote>
<p>git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（参见<a href="http://willi.am/blog/2014/08/12/the-dark-side-of-the-force-push/">这里</a>）。</p>
<h5 id="第七步：发出Pull-Request"><a href="#第七步：发出Pull-Request" class="headerlink" title="第七步：发出Pull Request"></a>第七步：发出Pull Request</h5><p>提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。</p>
<h3 id="常用-Git-命令清单"><a href="#常用-Git-命令清单" class="headerlink" title="常用 Git 命令清单"></a>常用 Git 命令清单</h3><p>作者： <a href="https://www.ruanyifeng.com/">阮一峰</a></p>
<p>我每天使用 Git ，但是很多命令记不住。</p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png"></p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h5 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h5><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h5><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h5 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h5><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<h5 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h5><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h5 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h5 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h5 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>



<h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p>作者： <a href="https://www.ruanyifeng.com/">阮一峰</a></p>
<p>日期： <a href="https://www.ruanyifeng.com/blog/2015/12/">2015年12月24日</a></p>
<p>Git 作为一个源码管理系统，不可避免涉及到多人协作。</p>
<p>协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122301.png" alt="img"></p>
<p>本文介绍三种广泛使用的工作流程：</p>
<blockquote>
<ul>
<li>Git flow</li>
<li>Github flow</li>
<li>Gitlab flow</li>
</ul>
</blockquote>
<p>如果你对Git还不是很熟悉，可以先阅读下面的文章。</p>
<blockquote>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2015/08/git-use-process.html">《Git 使用规范流程》</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">《常用 Git 命令清单》</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2014/06/git_remote.html">《Git 远程操作详解》</a></li>
</ul>
</blockquote>
<h3 id="一、功能驱动"><a href="#一、功能驱动" class="headerlink" title="一、功能驱动"></a>一、功能驱动</h3><p>本文的三种工作流程，有一个共同点：都采用<a href="https://en.wikipedia.org/wiki/Feature-driven_development">“功能驱动式开发”</a>（Feature-driven development，简称FDD）。</p>
<p>它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。</p>
<h3 id="二、Git-flow"><a href="#二、Git-flow" class="headerlink" title="二、Git flow"></a>二、Git flow</h3><p>最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/">Git flow</a> 。</p>
<h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><p>它最主要的特点有两个。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122302.png" alt="img"></p>
<p>首先，项目存在两个长期分支。</p>
<blockquote>
<ul>
<li>主分支<code>master</code></li>
<li>开发分支<code>develop</code></li>
</ul>
</blockquote>
<p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。</p>
<p>其次，项目存在三种短期分支。</p>
<blockquote>
<ul>
<li>功能分支（feature branch）</li>
<li>补丁分支（hotfix branch）</li>
<li>预发分支（release branch）</li>
</ul>
</blockquote>
<p>一旦完成开发，它们就会被合并进<code>develop</code>或<code>master</code>，然后被删除。</p>
<p>Git flow 的详细介绍，请阅读我翻译的中文版<a href="https://www.ruanyifeng.com/blog/2012/07/git.html">《Git 分支管理策略》</a>。</p>
<h4 id="2-2-评价"><a href="#2-2-评价" class="headerlink" title="2.2 评价"></a>2.2 评价</h4><p>Git flow的优点是清晰可控，缺点是相对复杂，需要同时维护两个长期分支。大多数工具都将<code>master</code>当作默认分支，可是开发是在<code>develop</code>分支进行的，这导致经常要切换分支，非常烦人。</p>
<p>更大问题在于，这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本。但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。这时，<code>master</code>分支和<code>develop</code>分支的差别不大，没必要维护两个长期分支。</p>
<h3 id="三、Github-flow"><a href="#三、Github-flow" class="headerlink" title="三、Github flow"></a>三、Github flow</h3><p><a href="http://scottchacon.com/2011/08/31/github-flow.html">Github flow</a> 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p>
<h4 id="3-1-流程"><a href="#3-1-流程" class="headerlink" title="3.1 流程"></a>3.1 流程</h4><p>它只有一个长期分支，就是<code>master</code>，因此用起来非常简单。</p>
<p>官方推荐的<a href="https://guides.github.com/introduction/flow/index.html">流程</a>如下。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122305.png" alt="img"></p>
<blockquote>
<p>第一步：根据需求，从<code>master</code>拉出新分支，不区分功能分支或补丁分支。</p>
<p>第二步：新分支开发完成后，或者需要讨论的时候，就向<code>master</code>发起一个<a href="https://help.github.com/articles/using-pull-requests/">pull request</a>（简称PR）。</p>
<p>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</p>
<p>第四步：你的Pull Request被接受，合并进<code>master</code>，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</p>
</blockquote>
<h4 id="3-2-评价"><a href="#3-2-评价" class="headerlink" title="3.2 评价"></a>3.2 评价</h4><p>Github flow 的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程。</p>
<p>问题在于它的假设：<code>master</code>分支的更新与产品的发布是一致的。也就是说，<code>master</code>分支的最新代码，默认就是当前的线上代码。</p>
<p>可是，有些时候并非如此，代码合并进入<code>master</code>分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，<code>master</code>分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于<code>master</code>分支。</p>
<p>上面这种情况，只有<code>master</code>一个主分支就不够用了。通常，你不得不在<code>master</code>分支以外，另外新建一个<code>production</code>分支跟踪线上版本。</p>
<h3 id="四、Gitlab-flow"><a href="#四、Gitlab-flow" class="headerlink" title="四、Gitlab flow"></a>四、Gitlab flow</h3><p><a href="https://docs.gitlab.com/ee/workflow/gitlab_flow.html">Gitlab flow</a> 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。</p>
<h4 id="4-1-上游优先"><a href="#4-1-上游优先" class="headerlink" title="4.1 上游优先"></a>4.1 上游优先</h4><p>Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支<code>master</code>，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p>
<p><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/upstream-first">Chromium项目</a>就是一个例子，它明确规定，上游分支依次为：</p>
<blockquote>
<ol>
<li>Linus Torvalds的分支</li>
<li>子系统（比如netdev）的分支</li>
<li>设备厂商（比如三星）的分支</li>
</ol>
</blockquote>
<h4 id="4-2-持续发布"><a href="#4-2-持续发布" class="headerlink" title="4.2 持续发布"></a>4.2 持续发布</h4><p>Gitlab flow 分成两种情况，适应不同的开发流程。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122306.png" alt="img"></p>
<p>对于”持续发布”的项目，它建议在<code>master</code>分支以外，再建立不同的环境分支。比如，”开发环境”的分支是<code>master</code>，”预发环境”的分支是<code>pre-production</code>，”生产环境”的分支是<code>production</code>。</p>
<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到<code>master</code>，确认没有问题，再<code>cherry-pick</code>到<code>pre-production</code>，这一步也没有问题，才进入<code>production</code>。</p>
<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
<h4 id="4-3-版本发布"><a href="#4-3-版本发布" class="headerlink" title="4.3 版本发布"></a>4.3 版本发布</h4><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122307.png" alt="img"></p>
<p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从<code>master</code>分支拉出一个分支，比如<code>2-3-stable</code>、<code>2-4-stable</code>等等。</p>
<p>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。</p>
<h3 id="五、一些小技巧"><a href="#五、一些小技巧" class="headerlink" title="五、一些小技巧"></a>五、一些小技巧</h3><h4 id="5-1-Pull-Request"><a href="#5-1-Pull-Request" class="headerlink" title="5.1 Pull Request"></a>5.1 Pull Request</h4><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122310.png" alt="img"></p>
<p>功能分支合并进<code>master</code>分支，必须通过Pull Request（Gitlab里面叫做 Merge Request）。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122308.png" alt="img"></p>
<p>前面说过，Pull Request本质是一种对话机制，你可以在提交的时候，<code>@</code>相关<a href="https://github.com/blog/1004-mention-autocompletion">人员</a>或<a href="https://github.com/blog/1121-introducing-team-mentions">团队</a>，引起他们的注意。</p>
<h4 id="5-2-Protected-branch"><a href="#5-2-Protected-branch" class="headerlink" title="5.2 Protected branch"></a>5.2 Protected branch</h4><p><code>master</code>分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权力。</p>
<p><a href="https://help.github.com/articles/about-protected-branches/">Github</a> 和 <a href="https://docs.gitlab.com/ce/permissions/permissions.html">Gitlab</a> 都提供”保护分支”（Protected branch）这个功能。</p>
<h4 id="5-3-Issue"><a href="#5-3-Issue" class="headerlink" title="5.3 Issue"></a>5.3 Issue</h4><p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。</p>
<p>功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”15-require-a-password-to-change-it”。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122311.png" alt="img"></p>
<p>开发完成后，在提交说明里面，可以写上”fixes #14”或者”closes #67”。Github规定，只要commit message里面有下面这些<a href="https://help.github.com/articles/closing-issues-via-commit-messages/">动词</a> + 编号，就会关闭对应的issue。</p>
<blockquote>
<ul>
<li>close</li>
<li>closes</li>
<li>closed</li>
<li>fix</li>
<li>fixes</li>
<li>fixed</li>
<li>resolve</li>
<li>resolves</li>
<li>resolved</li>
</ul>
</blockquote>
<p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是<code>username/repository#issue_number</code>。</p>
<p>Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p>
<h4 id="5-4-Merge节点"><a href="#5-4-Merge节点" class="headerlink" title="5.4 Merge节点"></a>5.4 Merge节点</h4><p>Git有两种合并：一种是”直进式合并”（fast forward），不生成单独的合并节点；另一种是”非直进式合并”（none fast-forword），会生成单独节点。</p>
<p>前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用<code>--no-ff</code>参数）。只要发生合并，就要有一个单独的合并节点。</p>
<h4 id="5-5-Squash-多个commit"><a href="#5-5-Squash-多个commit" class="headerlink" title="5.5 Squash 多个commit"></a>5.5 Squash 多个commit</h4><p>为了便于他人阅读你的提交，也便于<code>cherry-pick</code>或撤销代码变化，在发起Pull Request之前，应该把多个commit合并成一个。（前提是，该分支只有你一个人开发，且没有跟<code>master</code>合并过。）</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015122309.png" alt="img"></p>
<p>这可以采用<code>rebase</code>命令附带的<code>squash</code>操作，具体方法请参考我写的<a href="https://www.ruanyifeng.com/blog/2015/08/git-use-process.html">《Git 使用规范流程》</a>。</p>
<h2 id="git如果出现冲突怎么办"><a href="#git如果出现冲突怎么办" class="headerlink" title="git如果出现冲突怎么办 ?"></a>git如果出现冲突怎么办 ?</h2><h3 id="git冲突解决"><a href="#git冲突解决" class="headerlink" title="git冲突解决"></a>git冲突解决</h3><h4 id="1-简单分支管理的冲突解决："><a href="#1-简单分支管理的冲突解决：" class="headerlink" title="1.简单分支管理的冲突解决："></a>1.简单分支管理的冲突解决：</h4><p>当我们在master和feature1两个分支上都对同一个文件进行了修改提交后，现在我们要合并分支，这时git无法进行快速合并，可能会有冲突，我们可以使用git status 查看也可以直接查看文件（git 会自动标识 ） </p>
<p><img src="https://upload-images.jianshu.io/upload_images/2494440-ff788275fd8b47c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455" alt="img"></p>
<p>​                                                                    冲突示意图</p>
<p>解决办法：</p>
<p>A.在文件中选择一个版本保留，删除有冲突不需要保存的部分内容后，保存文件</p>
<p>B.再次提交</p>
<p>C.删除feature1分支</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2494440-5b4d691285746444.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/561" alt="img"></p>
<p>​                                                            解决冲突后的分支图</p>
<p>注：可用git log–graph命令可以看到分支合并图。</p>
<h4 id="2-多人协作时的冲突解决"><a href="#2-多人协作时的冲突解决" class="headerlink" title="2.多人协作时的冲突解决"></a>2.多人协作时的冲突解决</h4><p>当你的小伙伴将本地dev上的一个文件push到origin/dev上后，而碰巧你也修改了同一个文件打算push到远程，但此时会和你的小伙伴的提交有冲突。</p>
<p>解决办法：</p>
<p>A.用git pull 把最新的提交从origin/dev上拉取下来（第一次pull可能会失败，git可能会提示你没有指定本地的dev和origin/dev 的链接，一般根据提示采用 $git branch –set-upstream dev origin/dev建立链接，再次使用git pull）</p>
<p>B.现在你已经成功的拉取了远程最新的提交，但是合并有冲突，需要像上一例中手动解决，解决后再次提交。</p>
<p>C.提交成功后就可以push到远程了</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h1 id="git同样的先后提交的东西，怎么覆盖"><a href="#git同样的先后提交的东西，怎么覆盖" class="headerlink" title="git同样的先后提交的东西，怎么覆盖"></a>git同样的先后提交的东西，怎么覆盖</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>9.19-数据结构与算法1</title>
    <url>/2021/09/19/17-16-15/</url>
    <content><![CDATA[<p>1.什么是数据结构？</p>
<ul>
<li>数组、链表、队列、栈、堆、二叉树、图</li>
<li>如果一定要给出一个官方的解释，那么它就是：<br><strong>计算机存储、组织数据的方式。相互之间存在一种或多种特定关系的数据元素的集合。</strong>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。往往同高效的检索算法和索引技术有关。</li>
</ul>
<p>2.数据结构和算法的关系</p>
<ul>
<li>数据结构主要讲解数据的组织形式，比如链表，堆，栈，队列。</li>
<li>而算法，则注重的是思想，比如链表的元素怎么插入、删除、查找？堆的元素怎么弹出来？栈为什么是先进后出的？队列又为什么是先进先出？</li>
<li>讲的直白一点，数据结构是有实体的，算法是虚拟的；数据结构是物质上的，算法是精神上的。当然，精神与物质是缺一不可的。</li>
</ul>
<p>3.数据结构概览</p>
<p><img src="C:\Users\mylym\AppData\Roaming\Typora\typora-user-images\image-20210920005857021.png" alt="image-20210920005857021"></p>
<p>4.算法入门</p>
<p><img src="C:\Users\mylym\AppData\Roaming\Typora\typora-user-images\image-20210920005903869.png" alt="image-20210920005903869"></p>
<p><img src="C:\Users\mylym\AppData\Roaming\Typora\typora-user-images\image-20210920010119893.png" alt="image-20210920010119893"></p>
<h1 id="算法入门《前缀和》简单01-——-LeetCode-724-寻找数组的中心索引"><a href="#算法入门《前缀和》简单01-——-LeetCode-724-寻找数组的中心索引" class="headerlink" title="算法入门《前缀和》简单01 —— LeetCode 724 寻找数组的中心索引"></a><strong>算法入门</strong>《前缀和》简单01 —— LeetCode 724 寻找数组的中心索引</h1><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li><p>一、题目</p>
</li>
<li><ul>
<li>1、题目描述</li>
<li>2、基础框架</li>
<li>3、原题链接</li>
</ul>
</li>
<li><p>二、解题报告</p>
</li>
<li><ul>
<li>1、思路分析</li>
<li>2、时间复杂度</li>
<li>3、代码详解</li>
</ul>
</li>
<li><p>三、本题小知识</p>
</li>
</ul>
<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><h4 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><pre><code>  给定一个整数数组nums，请计算数组的中心下标 。数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1。
  样例输入： nums = [1, 7, 3, 6, 5, 6]
  样例输出： 3
</code></pre>
<h4 id="2、基础框架"><a href="#2、基础框架" class="headerlink" title="2、基础框架"></a>2、基础框架</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3、原题链接"><a href="#3、原题链接" class="headerlink" title="3、原题链接"></a>3、原题链接</h4><blockquote>
<p><a href="https://leetcode-cn.com/problems/find-pivot-index/">LeetCode 724. 寻找数组的中心下标</a><br> <a href="https://leetcode-cn.com/problems/tvdfij/">LeetCode 剑指 Offer II 012. 左右两边子数组的和相等</a></p>
</blockquote>
<h3 id="二、解题报告"><a href="#二、解题报告" class="headerlink" title="二、解题报告"></a>二、解题报告</h3><h4 id="1、思路分析"><a href="#1、思路分析" class="headerlink" title="1、思路分析"></a>1、思路分析</h4><p>记数组的全部元素之和为 sum，当遍历到第 i 个元素时，设其左侧元素之和为 curSum，则2×curSum+nums[i]=total.</p>
<p>当中心索引左侧或右侧没有元素时，即为零个项相加，这在数学上称作「空和」（empty sum）。在程序设计中我们约定「空和是零」。</p>
<h4 id="2、时间复杂度"><a href="#2、时间复杂度" class="headerlink" title="2、时间复杂度"></a>2、时间复杂度</h4><pre><code>总共两次遍历，一次计算前缀和，一次枚举判定，所以总的时间复杂度为 O(n)。
</code></pre>
<h4 id="3、代码详解"><a href="#3、代码详解" class="headerlink" title="3、代码详解"></a>3、代码详解</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = nums.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>pre + cur,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> curSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len = nums.length;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curSum*<span class="number">2</span> + nums[i] == sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curSum += nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三、本题小知识"><a href="#三、本题小知识" class="headerlink" title="三、本题小知识"></a>三、本题小知识</h3><p>前缀和 可以在  O(n) 的时间内进行预处理， O(1) 的时间进行求和。</p>
<h1 id="算法入门《前缀和》中等02-——-LeetCode-974-和可被K整除的子数组"><a href="#算法入门《前缀和》中等02-——-LeetCode-974-和可被K整除的子数组" class="headerlink" title="算法入门《前缀和》中等02 —— LeetCode 974 和可被K整除的子数组"></a><strong>算法入门</strong>《前缀和》中等02 —— LeetCode 974 和可被K整除的子数组</h1><h3 id="一、题目-1"><a href="#一、题目-1" class="headerlink" title="一、题目"></a>一、题目</h3><h4 id="1、题目描述-1"><a href="#1、题目描述-1" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><pre><code>  给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
  样例输入： A = [4,5,0,-2,-3,1], K = 5
  样例输出： 7
</code></pre>
<h4 id="2、基础框架-1"><a href="#2、基础框架-1" class="headerlink" title="2、基础框架"></a>2、基础框架</h4><pre><code>/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var subarraysDivByK = function(nums, k) &#123;

&#125;;
</code></pre>
<h4 id="3、原题链接-1"><a href="#3、原题链接-1" class="headerlink" title="3、原题链接"></a>3、原题链接</h4><blockquote>
<p><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">LeetCode 974. 和可被 K 整除的子数组</a></p>
</blockquote>
<h3 id="二、解题报告-1"><a href="#二、解题报告-1" class="headerlink" title="二、解题报告"></a>二、解题报告</h3><h4 id="1、思路分析-1"><a href="#1、思路分析-1" class="headerlink" title="1、思路分析"></a>1、思路分析</h4><p>作者：xiao_ben_zhu<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/solution/you-jian-qian-zhui-he-na-jiu-zai-ci-dai-ni-da-tong/">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/solution/you-jian-qian-zhui-he-na-jiu-zai-ci-dai-ni-da-tong/</a><br>来源：力扣（LeetCode）</p>
<p><strong>什么是前缀和</strong></p>
<pre><code>前缀和：数组 第 0 项 到 当前项 的和。用一个数组 preSum 表示：
preSum[i]=A[0]+A[1]+…+A[i]

数组第 i 项可以表示为相邻前缀和之差：
A[i]=preSum[i]−preSum[i−1]

多项叠加，有：
A[i]+…+A[j]=preSum[j]−preSum[i−1]

i 可以为 0，此时 i - 1 为 - 1，我们故意让 preSum[−1] 为 0，此时有：
A[0]+A[1]+…+A[j]=preSum[j]
设置这种不存在的情况，只是为了让边界情况也能套用通式。
</code></pre>
<p><strong>题目等价转化</strong></p>
<pre><code>子数组的元素之和 =&gt; A[i] 到 A[j]的和
元素和能被 K 整除的子数组数目 =&gt; 有几种i、j组合，使得A[i]到A[j]之和 mod K == 0
↓ ↓ ↓ 转化为 ↓ ↓ ↓
有几种 i、j 组合，满足 (preSum[j]−preSum[i−1])mod K==0
有几种 i、j 组合，满足 preSum[j] mod K == preSum[i−1]mod K。
    前提：preSum[j] 、preSum[i−1] 为正整数。负数的情况要处理。
</code></pre>
<p><strong>前缀和怎么求</strong></p>
<pre><code>数组当前项的前缀和 = 上一项的前缀和 + 数组当前项
我们可以求出数组 A 每一项的前缀和，让它 mod K，mod 完再看哪两项相等，去计数。
但前面通式有i、j两个变量，找出所有相等的两项，需要两层循环，能否优化呢？
</code></pre>
<p>我们只关心：<strong>数值和出现次数</strong></p>
<pre><code>数组A的元素都有自己的前缀和，但我们不关心前缀和对应了哪一项。我们只关心出现过哪些「前缀和 mod K」的值，以及出现这个值的次数。
用一个变量 preSumModK，将每次求出的「前缀和 mod K」，存入哈希表：
    key：前缀和 mod K
    value：这个值出现的次数
「前缀和 mod K」值恰好是 0,1,2...,K-1，正好和索引对应，所以也可以用数组去存。
</code></pre>
<p>找到 preSumModK 的递推关系，用于迭代计算</p>
<pre><code>模的分配率： (a + b) mod c = (a mod c + b mod c) mod c
当前的 preSumModK
= ( 当前的前缀和 ) mod K
= ( 上一项的前缀和 + A[i]) mod K
= ( 上一项的前缀和) mod K + A[i]mod K) mod K
= ( 上一个 preSumModK + A[i] mod K ) mod K
= ( 上一个 preSumModK + A[i] ) mod K
前后的 preSumModK 有了递推关系，可以在迭代中计算。
</code></pre>
<p>整个流程</p>
<pre><code>预置 preSum[-1] = 0
    遍历数组 A 之前，map 提前放入 0:1 键值对，代表求第 0 项前缀和之前，前缀和 mod K 等于 0 这种情况出现了 1 次。
遍历数组 A，求当前项的 preSumModK ，存入 map 中：
    之前没有存过，则作为 key 存入，value 为 1。
    之前存过了，则 value 加 1。
边存边查看，如果 map 中已经存在 key 等于当前的 preSumModK：
    说明存在之前求过的 preSumModK 等于 当前 preSumModK，把 key 对应的出现次数，累加给 count。
    过去的这个前缀，与当前的前缀，差分出一个子数组，过去的这个前缀和出现过几次 ，就是有几个过去的前缀，与当前前缀，差分出几个满足条件的子数组。
</code></pre>
<p>尝试一句话概括</p>
<pre><code>根据当前前缀和 mod K，在哈希表中找到与之相等的 key。满足条件的 历史preSumModK 出现过 n 次，就是当前前缀和 能找到 n 个历史前缀和，与之形成 n 个不同的子数组，满足元素和能被 K 整除。
遍历数组 A 每一项，做以上步骤，n 不断累加给 count，最后返回 count
</code></pre>
<p>补充：前缀和 为负数 的情况</p>
<pre><code>拿K = 4为例，求出某个前缀和为 -1，-1 % K 应该为 3，但有的编程语言 -1 % K = -1
这个 -1，要加上 K，转成正数的 3。
为什么？为什么 preSum 值为 -1 和 3 需要归为同一类？因为：
-1 和 3 分别模 4 的结果看似不相等，但前缀和之差：3-(-1) 等于 4。4 % K = 0，即所形成的子数组满足元素和被 4 整除。所以前缀和 -1 和 3 其实是等价的。
</code></pre>
<h4 id="2、复杂度"><a href="#2、复杂度" class="headerlink" title="2、复杂度"></a>2、复杂度</h4><p>Time：O(n)<br> Space：O(K)。 mod 的结果最多 K 种，哈希表最多存放 K 个键值对</p>
<h4 id="3、代码详解-1"><a href="#3、代码详解-1" class="headerlink" title="3、代码详解"></a>3、代码详解</h4><h5 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subarraysDivByK = <span class="function">(<span class="params">A, K</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> preSumModK = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = &#123; <span class="number">0</span>: <span class="number">1</span> &#125;;<span class="comment">// 初始化哈希表，并且插入第一个元素sum[-1]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    preSumModK = (preSumModK + A[i]) % K; <span class="comment">// 递推式子 计算前缀和模 k</span></span><br><span class="line">    <span class="keyword">if</span> (preSumModK &lt; <span class="number">0</span>) &#123;  <span class="comment">//确保每个sum[i]都是大于等于0的；</span></span><br><span class="line">      preSumModK += K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map[preSumModK]) &#123;      <span class="comment">// 已经存在于map</span></span><br><span class="line">      count += map[preSumModK]; <span class="comment">// 把对应的次数累加给count</span></span><br><span class="line">      map[preSumModK]++;        <span class="comment">// 并且更新出现次数，次数+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map[preSumModK] = <span class="number">1</span>;      <span class="comment">// 之前没出现过，初始化值为1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：xiao_ben_zhu</span><br></pre></td></tr></table></figure>

<h5 id="解法2：用数组代替哈希表存mod"><a href="#解法2：用数组代替哈希表存mod" class="headerlink" title="解法2：用数组代替哈希表存mod"></a>解法2：用数组代替哈希表存mod</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subarraysDivByK = <span class="function">(<span class="params">A, K</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> preSumModK = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Array</span>(K).fill(<span class="number">0</span>);</span><br><span class="line">  map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;     </span><br><span class="line">    preSumModK = (preSumModK + A[i]) % K;</span><br><span class="line">    <span class="keyword">if</span> (preSumModK &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      preSumModK += K;</span><br><span class="line">    &#125;</span><br><span class="line">    count += map[preSumModK]; <span class="comment">// 索引对应模的结果，值对应出现次数</span></span><br><span class="line">    map[preSumModK]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：xiao_ben_zhu</span><br></pre></td></tr></table></figure>



<h3 id="三、本题小知识-1"><a href="#三、本题小知识-1" class="headerlink" title="三、本题小知识"></a>三、本题小知识</h3><pre><code>前缀和的问题，一般是先初始化前缀和，然后再进行一次线性枚举，通过 O(1) 的时间取前缀和的结果。
</code></pre>
<h1 id="算法入门《前缀和》中等03-——-LeetCode-1248-统计-优美子数组"><a href="#算法入门《前缀和》中等03-——-LeetCode-1248-统计-优美子数组" class="headerlink" title="算法入门《前缀和》中等03 —— LeetCode 1248 统计[优美子数组]"></a><strong>算法入门</strong>《前缀和》中等03 —— LeetCode 1248 统计[优美子数组]</h1><h3 id="一、题目-2"><a href="#一、题目-2" class="headerlink" title="一、题目"></a>一、题目</h3><h4 id="1、题目描述-2"><a href="#1、题目描述-2" class="headerlink" title="1、题目描述"></a>1、题目描述</h4><pre><code>  给你一个整数数组 nums 和一个整数 k 。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。
  样例输入： nums = [1,1,2,1,1], k = 3
  样例输出： 2
</code></pre>
<h4 id="2、基础框架-2"><a href="#2、基础框架-2" class="headerlink" title="2、基础框架"></a>2、基础框架</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numberOfSubarrays = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3、原题链接-2"><a href="#3、原题链接-2" class="headerlink" title="3、原题链接"></a>3、原题链接</h4><blockquote>
<p><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">LeetCode 1248. 统计「优美子数组」</a></p>
</blockquote>
<h3 id="二、解题报告-2"><a href="#二、解题报告-2" class="headerlink" title="二、解题报告"></a>二、解题报告</h3><h4 id="1、思路分析-2"><a href="#1、思路分析-2" class="headerlink" title="1、思路分析"></a>1、思路分析</h4><p>用一个数组变量 count[ ] 来记录奇数个数有a个的连续子数组有count[a]个，用一个整数变量result来记录满足条件的子数组的个数，result的值是当前奇数个数与k值的比较，如果大于等于，则在result上添加count[odd-k]</p>
<h4 id="2、复杂度-1"><a href="#2、复杂度-1" class="headerlink" title="2、复杂度"></a>2、复杂度</h4><p>Time：O(n)</p>
<h4 id="3、代码详解-2"><a href="#3、代码详解-2" class="headerlink" title="3、代码详解"></a>3、代码详解</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numberOfSubarrays = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    len = nums.length</span><br><span class="line">    <span class="keyword">let</span> count = <span class="keyword">new</span> <span class="built_in">Array</span>(len+<span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    count[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> odd = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result =<span class="number">0</span></span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">value,index</span>)=&gt;</span>&#123;</span><br><span class="line">        odd+=value&amp;<span class="number">1</span></span><br><span class="line">        result += odd&gt;=k?count[odd-k]:<span class="number">0</span> <span class="comment">// 给前面留出odd-k个奇数，后面就有k个了</span></span><br><span class="line">        count[odd]++</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、本题小知识-2"><a href="#三、本题小知识-2" class="headerlink" title="三、本题小知识"></a>三、本题小知识</h3><pre><code>(1) x &amp; 1为 1 代表是奇数，否则是偶数；
(2) 计算前缀有多少个奇数；
</code></pre>
<h2 id="算法入门《线性枚举》简单01-——-LeetCode-344-反转字符串"><a href="#算法入门《线性枚举》简单01-——-LeetCode-344-反转字符串" class="headerlink" title="算法入门《线性枚举》简单01 —— LeetCode 344 反转字符串"></a><strong>算法入门</strong>《线性枚举》简单01 —— LeetCode 344 反转字符串</h2>]]></content>
  </entry>
</search>
